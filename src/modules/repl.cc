// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

#include <gearbox.h>

using namespace Gearbox;

/** \file src/modules/repl.cc converted from src/modules/repl.js */



#line 30 "src/modules/repl.cc"
static void _setup_repl(Value exports, Value require, Value module) {
    Context::getCurrent()->runScript("(function(exports, require, module){\n\n/* A repl library that you can include in your own code to get a runtime\n * interface to your program.\n *\n *   var repl = require(\"/repl.js\");\n *   // start repl on stdin\n *   repl.start(\"prompt> \");\n *\n *   // listen for unix socket connections and start repl on them\n *   net.createServer(function (socket) {\n *     repl.start(\"node via Unix socket> \", socket);\n *   }).listen(\"/tmp/node-repl-sock\");\n *\n *   // listen for TCP socket connections and start repl on them\n *   net.createServer(function (socket) {\n *     repl.start(\"node via TCP socket> \", socket);\n *   }).listen(5001);\n *\n *   // expose foo to repl context\n *   repl.start(\"node > \").context.foo = \"stdin is fun\";\n */\n\nvar util = require('util');\nvar vm = require('vm');\nvar path = require('path');\nvar fs = require('fs');\nvar rl = require('readline');\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n\nvar context;\n\nexports.disableColors = process.env.NODE_DISABLE_COLORS ? true : false;\n\n// hack for require.resolve(\"./relative\") to work properly.\nmodule.filename = process.cwd() + '/repl';\n\n// hack for repl require to work properly with node_modules folders\nmodule.paths = require('module')._nodeModulePaths(module.filename);\n\n// Can overridden with custom print functions, such as `probe` or `eyes.js`\nexports.writer = util.inspect;\n\n\nfunction REPLServer(prompt, stream, eval, useGlobal, ignoreUndefined) {\n  var self = this;\n\n  self.useGlobal = useGlobal;\n\n  self.eval = eval || function(code, context, file, cb) {\n    var err, result;\n    try {\n      if (useGlobal) {\n        result = vm.runInThisContext(code, file);\n      } else {\n        result = vm.runInContext(code, context, file);\n      }\n    } catch (e) {\n      err = e;\n    }\n    cb(err, result);\n  };\n\n  self.resetContext();\n  self.bufferedCommand = '';\n\n  if (stream) {\n    // We're given a duplex socket\n    if (stream.stdin || stream.stdout) {\n      self.outputStream = stream.stdout;\n      self.inputStream = stream.stdin;\n    } else {\n      self.outputStream = stream;\n      self.inputStream = stream;\n    }\n  } else {\n    self.outputStream = process.stdout;\n    self.inputStream = process.stdin;\n    process.stdin.resume();\n  }\n\n  self.prompt = (prompt != undefined ? prompt : '> ');\n\n  function complete(text, callback) {\n    self.complete(text, callback);\n  }\n\n  var rli = rl.createInterface(self.inputStream, self.outputStream, complete);\n  self.rli = rli;\n\n  this.commands = {};\n  defineDefaultCommands(this);\n\n  if (rli.enabled && !exports.disableColors &&\n      exports.writer === util.inspect) {\n    // Turn on ANSI coloring.\n    exports.writer = function(obj, showHidden, depth) {\n      return util.inspect(obj, showHidden, depth, true);\n    };\n  }\n\n  rli.setPrompt(self.prompt);\n\n  var sawSIGINT = false;\n  rli.on('SIGINT', function() {\n    if (sawSIGINT) {\n      rli.close();\n      process.exit();\n    }\n\n    rli.line = '';\n\n    if (!(self.bufferedCommand && self.bufferedCommand.length > 0) &&\n        rli.line.length === 0) {\n      rli.output.write('\\n(^C again to quit)\\n');\n      sawSIGINT = true;\n    } else {\n      rli.output.write('\\n');\n    }\n\n    self.bufferedCommand = '';\n    self.displayPrompt();\n  });\n\n  rli.addListener('line', function(cmd) {\n    sawSIGINT = false;\n    var skipCatchall = false;\n    cmd = trimWhitespace(cmd);\n\n    // Check to see if a REPL keyword was used. If it returns true,\n    // display next prompt and return.\n    if (cmd && cmd.charAt(0) === '.') {\n      var matches = cmd.match(/^(\\.[^\\s]+)\\s*(.*)$/);\n      var keyword = matches && matches[1];\n      var rest = matches && matches[2];\n      if (self.parseREPLKeyword(keyword, rest) === true) {\n        return;\n      } else {\n        self.outputStream.write('Invalid REPL keyword\\n');\n        skipCatchall = true;\n      }\n    }\n\n    if (!skipCatchall) {\n      var evalCmd = self.bufferedCommand + cmd + '\\n';\n\n      // This try is for determining if the command is complete, or should\n      // continue onto the next line.\n      // We try to evaluate both expressions e.g.\n      //  '{ a : 1 }'\n      // and statements e.g.\n      //  'for (var i = 0; i < 10; i++) console.log(i);'\n\n      // First we attempt to eval as expression with parens.\n      // This catches '{a : 1}' properly.\n      self.eval('(' + evalCmd + ')',\n                self.context,\n                'repl',\n                function(e, ret) {\n            if (e && !isSyntaxError(e)) return finish(e);\n\n            if (typeof ret === 'function' || e) {\n              // Now as statement without parens.\n              self.eval(evalCmd, self.context, 'repl', finish);\n            } else {\n              finish(null, ret);\n            }\n          });\n\n    } else {\n      finish(null);\n    }\n\n    function isSyntaxError(e) {\n      // Convert error to string\n      e = e && (e.stack || e.toString());\n      return e && e.match(/^SyntaxError/) &&\n             !(e.match(/^SyntaxError: Unexpected token .*\\n/) &&\n             e.match(/\\n    at Object.parse \\(native\\)\\n/));\n    }\n\n    function finish(e, ret) {\n\n      self.memory(cmd);\n\n      // If error was SyntaxError and not JSON.parse error\n      if (isSyntaxError(e)) {\n        // Start buffering data like that:\n        // {\n        // ...  x: 1\n        // ... }\n        self.bufferedCommand += cmd + '\\n';\n        self.displayPrompt();\n        return;\n      } else if (e) {\n        self.outputStream.write((e.stack || e) + '\\n');\n      }\n\n      // Clear buffer if no SyntaxErrors\n      self.bufferedCommand = '';\n\n      // If we got any output - print it (if no error)\n      if (!e && (!ignoreUndefined || ret !== undefined)) {\n        self.context._ = ret;\n        self.outputStream.write(exports.writer(ret) + '\\n');\n      }\n\n      // Display prompt again\n      self.displayPrompt();\n    };\n  });\n\n  rli.addListener('close', function() {\n    self.inputStream.destroy();\n  });\n\n  self.displayPrompt();\n}\nexports.REPLServer = REPLServer;\n\n\n// prompt is a string to print on each line for the prompt,\n// source is a stream to use for I/O, defaulting to stdin/stdout.\nexports.start = function(prompt, source, eval, useGlobal) {\n  var repl = new REPLServer(prompt, source, eval, useGlobal);\n  if (!exports.repl) exports.repl = repl;\n  return repl;\n};\n\n\nREPLServer.prototype.createContext = function() {\n  if (!this.useGlobal) {\n    var context = vm.createContext();\n    for (var i in global) context[i] = global[i];\n  } else {\n    var context = global;\n  }\n\n  context.module = module;\n  context.require = require;\n  context.global = context;\n  context.global.global = context;\n\n  this.lines = [];\n  this.lines.level = [];\n\n  return context;\n};\n\nREPLServer.prototype.resetContext = function(force) {\n  if (!context || force) {\n    context = this.createContext();\n    for (var i in require.cache) delete require.cache[i];\n  }\n\n  this.context = context;\n};\n\nREPLServer.prototype.displayPrompt = function() {\n  this.rli.setPrompt(this.bufferedCommand.length ?\n                 '...' + new Array(this.lines.level.length).join('..') + ' ' :\n                 this.prompt);\n  this.rli.prompt();\n};\n\n\n// read a line from the stream, then eval it\nREPLServer.prototype.readline = function(cmd) {\n};\n\n// A stream to push an array into a REPL\n// used in REPLServer.complete\nfunction ArrayStream() {\n  this.run = function (data) {\n    var self = this;\n    data.forEach(function (line) {\n      self.emit('data', line);\n    });\n  }\n}\nutil.inherits(ArrayStream, require('stream').Stream);\nArrayStream.prototype.readable = true;\nArrayStream.prototype.writable = true;\nArrayStream.prototype.resume = function () {};\nArrayStream.prototype.write = function () {};\n\nvar requireRE = /\\brequire\\s*\\(['\"](([\\w\\.\\/-]+\\/)?([\\w\\.\\/-]*))/;\nvar simpleExpressionRE =\n    /(([a-zA-Z_$](?:\\w|\\$)*)\\.)*([a-zA-Z_$](?:\\w|\\$)*)\\.?$/;\n\n\n// Provide a list of completions for the given leading text. This is\n// given to the readline interface for handling tab completion.\n//\n// Example:\n//  complete('var foo = util.')\n//    -> [['util.print', 'util.debug', 'util.log', 'util.inspect', 'util.pump'],\n//        'util.' ]\n//\n// Warning: This eval's code like \"foo.bar.baz\", so it will run property\n// getter code.\nREPLServer.prototype.complete = function(line, callback) {\n  // There may be local variables to evaluate, try a nested REPL\n  if (this.bufferedCommand != undefined && this.bufferedCommand.length) {\n    // Get a new array of inputed lines\n    var tmp = this.lines.slice();\n    // Kill off all function declarations to push all local variables into\n    // global scope\n    this.lines.level.forEach(function (kill) {\n      if (kill.isFunction) {\n        tmp[kill.line] = '';\n      }\n    });\n    var flat = new ArrayStream();         // make a new \"input\" stream\n    var magic = new REPLServer('', flat); // make a nested REPL\n    magic.context = magic.createContext();\n    flat.run(tmp);                        // eval the flattened code\n    // all this is only profitable if the nested REPL\n    // does not have a bufferedCommand\n    if (!magic.bufferedCommand) {\n      return magic.complete(line, callback);\n    }\n  }\n\n  var completions;\n\n  // list of completion lists, one for each inheritance \"level\"\n  var completionGroups = [];\n\n  var completeOn, match, filter, i, j, group, c;\n\n  // REPL commands (e.g. \".break\").\n  var match = null;\n  match = line.match(/^\\s*(\\.\\w*)$/);\n  if (match) {\n    completionGroups.push(Object.keys(this.commands));\n    completeOn = match[1];\n    if (match[1].length > 1) {\n      filter = match[1];\n    }\n\n    completionGroupsLoaded();\n  } else if (match = line.match(requireRE)) {\n    // require('...<Tab>')\n    //TODO: suggest require.exts be exposed to be introspec registered\n    //extensions?\n    //TODO: suggest include the '.' in exts in internal repr: parity with\n    //`path.extname`.\n    var exts = ['.js', '.node'];\n    var indexRe = new RegExp('^index(' + exts.map(regexpEscape).join('|') +\n                             ')$');\n\n    completeOn = match[1];\n    var subdir = match[2] || '';\n    var filter = match[1];\n    var dir, files, f, name, base, ext, abs, subfiles, s;\n    group = [];\n    var paths = module.paths.concat(require('module').globalPaths);\n    for (i = 0; i < paths.length; i++) {\n      dir = path.resolve(paths[i], subdir);\n      try {\n        files = fs.readdirSync(dir);\n      } catch (e) {\n        continue;\n      }\n      for (f = 0; f < files.length; f++) {\n        name = files[f];\n        ext = path.extname(name);\n        base = name.slice(0, -ext.length);\n        if (base.match(/-\\d+\\.\\d+(\\.\\d+)?/) || name === '.npm') {\n          // Exclude versioned names that 'npm' installs.\n          continue;\n        }\n        if (exts.indexOf(ext) !== -1) {\n          if (!subdir || base !== 'index') {\n            group.push(subdir + base);\n          }\n        } else {\n          abs = path.resolve(dir, name);\n          try {\n            if (fs.statSync(abs).isDirectory()) {\n              group.push(subdir + name + '/');\n              subfiles = fs.readdirSync(abs);\n              for (s = 0; s < subfiles.length; s++) {\n                if (indexRe.test(subfiles[s])) {\n                  group.push(subdir + name);\n                }\n              }\n            }\n          } catch (e) {}\n        }\n      }\n    }\n    if (group.length) {\n      completionGroups.push(group);\n    }\n\n    if (!subdir) {\n      // Kind of lame that this needs to be updated manually.\n      // Intentionally excluding moved modules: posix, utils.\n      var builtinLibs = ['assert', 'buffer', 'child_process', 'crypto', 'dgram',\n        'dns', 'events', 'file', 'freelist', 'fs', 'http', 'net', 'os', 'path',\n        'querystring', 'readline', 'repl', 'string_decoder', 'util', 'tcp',\n        'url'];\n      completionGroups.push(builtinLibs);\n    }\n\n    completionGroupsLoaded();\n\n  // Handle variable member lookup.\n  // We support simple chained expressions like the following (no function\n  // calls, etc.). That is for simplicity and also because we *eval* that\n  // leading expression so for safety (see WARNING above) don't want to\n  // eval function calls.\n  //\n  //   foo.bar<|>     # completions for 'foo' with filter 'bar'\n  //   spam.eggs.<|>  # completions for 'spam.eggs' with filter ''\n  //   foo<|>         # all scope vars with filter 'foo'\n  //   foo.<|>        # completions for 'foo' with filter ''\n  } else if (line.length === 0 || line[line.length - 1].match(/\\w|\\.|\\$/)) {\n    match = simpleExpressionRE.exec(line);\n    if (line.length === 0 || match) {\n      var expr;\n      completeOn = (match ? match[0] : '');\n      if (line.length === 0) {\n        filter = '';\n        expr = '';\n      } else if (line[line.length - 1] === '.') {\n        filter = '';\n        expr = match[0].slice(0, match[0].length - 1);\n      } else {\n        var bits = match[0].split('.');\n        filter = bits.pop();\n        expr = bits.join('.');\n      }\n\n      // console.log(\"expression completion: completeOn='\" + completeOn +\n      //             \"' expr='\" + expr + \"'\");\n\n      // Resolve expr and get its completions.\n      var obj, memberGroups = [];\n      if (!expr) {\n        // If context is instance of vm.ScriptContext\n        // Get global vars synchronously\n        if (this.useGlobal ||\n            this.context.constructor &&\n            this.context.constructor.name === 'Context') {\n          completionGroups.push(Object.getOwnPropertyNames(this.context));\n          addStandardGlobals();\n          completionGroupsLoaded();\n        } else {\n          this.eval('.scope', this.context, 'repl', function(err, globals) {\n            if (err || !globals) {\n              addStandardGlobals();\n            } else if (Array.isArray(globals[0])) {\n              // Add grouped globals\n              globals.forEach(function(group) {\n                completionGroups.push(group);\n              });\n            } else {\n              completionGroups.push(globals);\n              addStandardGlobals();\n            }\n            completionGroupsLoaded();\n          });\n        }\n\n        function addStandardGlobals() {\n          // Global object properties\n          // (http://www.ecma-international.org/publications/standards/Ecma-262.htm)\n          completionGroups.push(['NaN', 'Infinity', 'undefined',\n            'eval', 'parseInt', 'parseFloat', 'isNaN', 'isFinite', 'decodeURI',\n            'decodeURIComponent', 'encodeURI', 'encodeURIComponent',\n            'Object', 'Function', 'Array', 'String', 'Boolean', 'Number',\n            'Date', 'RegExp', 'Error', 'EvalError', 'RangeError',\n            'ReferenceError', 'SyntaxError', 'TypeError', 'URIError',\n            'Math', 'JSON']);\n          // Common keywords. Exclude for completion on the empty string, b/c\n          // they just get in the way.\n          if (filter) {\n            completionGroups.push(['break', 'case', 'catch', 'const',\n              'continue', 'debugger', 'default', 'delete', 'do', 'else',\n              'export', 'false', 'finally', 'for', 'function', 'if',\n              'import', 'in', 'instanceof', 'let', 'new', 'null', 'return',\n              'switch', 'this', 'throw', 'true', 'try', 'typeof', 'undefined',\n              'var', 'void', 'while', 'with', 'yield']);\n          }\n        }\n\n      } else {\n        this.eval(expr, this.context, 'repl', function(e, obj) {\n          // if (e) console.log(e);\n\n          if (obj != null) {\n            if (typeof obj === 'object' || typeof obj === 'function') {\n              memberGroups.push(Object.getOwnPropertyNames(obj));\n            }\n            // works for non-objects\n            try {\n              var p = Object.getPrototypeOf(obj);\n              var sentinel = 5;\n              while (p !== null) {\n                memberGroups.push(Object.getOwnPropertyNames(p));\n                p = Object.getPrototypeOf(p);\n                // Circular refs possible? Let's guard against that.\n                sentinel--;\n                if (sentinel <= 0) {\n                  break;\n                }\n              }\n            } catch (e) {\n              //console.log(\"completion error walking prototype chain:\" + e);\n            }\n          }\n\n          if (memberGroups.length) {\n            for (i = 0; i < memberGroups.length; i++) {\n              completionGroups.push(memberGroups[i].map(function(member) {\n                return expr + '.' + member;\n              }));\n            }\n            if (filter) {\n              filter = expr + '.' + filter;\n            }\n          }\n\n          completionGroupsLoaded();\n        });\n      }\n    } else {\n      completionGroupsLoaded();\n    }\n  }\n\n  // Will be called when all completionGroups are in place\n  // Useful for async autocompletion\n  function completionGroupsLoaded(err) {\n    if (err) throw err;\n\n    // Filter, sort (within each group), uniq and merge the completion groups.\n    if (completionGroups.length && filter) {\n      var newCompletionGroups = [];\n      for (i = 0; i < completionGroups.length; i++) {\n        group = completionGroups[i].filter(function(elem) {\n          return elem.indexOf(filter) == 0;\n        });\n        if (group.length) {\n          newCompletionGroups.push(group);\n        }\n      }\n      completionGroups = newCompletionGroups;\n    }\n\n    if (completionGroups.length) {\n      var uniq = {};  // unique completions across all groups\n      completions = [];\n      // Completion group 0 is the \"closest\"\n      // (least far up the inheritance chain)\n      // so we put its completions last: to be closest in the REPL.\n      for (i = completionGroups.length - 1; i >= 0; i--) {\n        group = completionGroups[i];\n        group.sort();\n        for (var j = 0; j < group.length; j++) {\n          c = group[j];\n          if (!hasOwnProperty(c)) {\n            completions.push(c);\n            uniq[c] = true;\n          }\n        }\n        completions.push(''); // separator btwn groups\n      }\n      while (completions.length && completions[completions.length - 1] === '') {\n        completions.pop();\n      }\n    }\n\n    callback(null, [completions || [], completeOn]);\n  }\n};\n\n\n/**\n * Used to parse and execute the Node REPL commands.\n *\n * @param {keyword} keyword The command entered to check.\n * @return {Boolean} If true it means don't continue parsing the command.\n */\nREPLServer.prototype.parseREPLKeyword = function(keyword, rest) {\n  var cmd = this.commands[keyword];\n  if (cmd) {\n    cmd.action.call(this, rest);\n    return true;\n  }\n  return false;\n};\n\n\nREPLServer.prototype.defineCommand = function(keyword, cmd) {\n  if (typeof cmd === 'function') {\n    cmd = {action: cmd};\n  } else if (typeof cmd.action !== 'function') {\n    throw new Error('bad argument, action must be a function');\n  }\n  this.commands['.' + keyword] = cmd;\n};\n\nREPLServer.prototype.memory = function memory (cmd) {\n  var self = this;\n\n  self.lines = self.lines || [];\n  self.lines.level = self.lines.level || [];\n\n  // save the line so I can do magic later\n  if (cmd) {\n    // TODO should I tab the level?\n    self.lines.push(new Array(self.lines.level.length).join('  ') + cmd);\n  } else {\n    // I don't want to not change the format too much...\n    self.lines.push('');\n  }\n\n  // I need to know \"depth.\"\n  // Because I can not tell the difference between a } that\n  // closes an object literal and a } that closes a function\n  if (cmd) {\n    // going down is { and (   e.g. function () {\n    // going up is } and )\n    var dw = cmd.match(/{|\\(/g);\n    var up = cmd.match(/}|\\)/g);\n    up = up ? up.length : 0;\n    dw = dw ? dw.length : 0;\n    var depth = dw - up;\n\n    if (depth) {\n      (function workIt(){\n        if (depth > 0) {\n          // going... down.\n          // push the line#, depth count, and if the line is a function.\n          // Since JS only has functional scope I only need to remove\n          // \"function () {\" lines, clearly this will not work for\n          // \"function ()\n          // {\" but nothing should break, only tab completion for local\n          // scope will not work for this function.\n          self.lines.level.push({ line: self.lines.length - 1,\n                                depth: depth,\n                                isFunction: /\\s*function\\s*/.test(cmd)});\n        } else if (depth < 0) {\n          // going... up.\n          var curr = self.lines.level.pop();\n          if (curr) {\n            var tmp = curr.depth + depth;\n            if (tmp < 0) {\n              //more to go, recurse\n              depth += curr.depth;\n              workIt();\n            } else if (tmp > 0) {\n              //remove and push back\n              curr.depth += depth;\n              self.lines.level.push(curr);\n            }\n          }\n        }\n      }());\n    }\n\n    // it is possible to determine a syntax error at this point.\n    // if the REPL still has a bufferedCommand and\n    // self.lines.level.length === 0\n    // TODO? keep a log of level so that any syntax breaking lines can\n    // be cleared on .break and in the case of a syntax error?\n    // TODO? if a log was kept, then I could clear the bufferedComand and\n    // eval these lines and throw the syntax error\n  } else {\n    self.lines.level = [];\n  }\n};\n\n\nfunction defineDefaultCommands(repl) {\n  // TODO remove me after 0.3.x\n  repl.defineCommand('break', {\n    help: 'Sometimes you get stuck, this gets you out',\n    action: function() {\n      this.bufferedCommand = '';\n      this.displayPrompt();\n    }\n  });\n\n  repl.defineCommand('clear', {\n    help: 'Break, and also clear the local context',\n    action: function() {\n      this.outputStream.write('Clearing context...\\n');\n      this.bufferedCommand = '';\n      this.resetContext(true);\n      this.displayPrompt();\n    }\n  });\n\n  repl.defineCommand('exit', {\n    help: 'Exit the repl',\n    action: function() {\n      this.rli.close();\n    }\n  });\n\n  repl.defineCommand('help', {\n    help: 'Show repl options',\n    action: function() {\n      var self = this;\n      Object.keys(this.commands).sort().forEach(function(name) {\n        var cmd = self.commands[name];\n        self.outputStream.write(name + '\\t' + (cmd.help || '') + '\\n');\n      });\n      this.displayPrompt();\n    }\n  });\n\n  repl.defineCommand('save', {\n    help: 'Save all evaluated commands in this REPL session to a file',\n    action: function(file) {\n      try {\n        fs.writeFileSync(file, this.lines.join('\\n') + '\\n');\n        this.outputStream.write('Session saved to:' + file + '\\n');\n      } catch (e) {\n        this.outputStream.write('Failed to save:' + file+ '\\n')\n      }\n      this.displayPrompt();\n    }\n  });\n\n  repl.defineCommand('load', {\n    help: 'Load JS from a file into the REPL session',\n    action: function(file) {\n      try {\n        var stats = fs.statSync(file);\n        if (stats && stats.isFile()) {\n          var self = this;\n          var data = fs.readFileSync(file, 'utf8');\n          var lines = data.split('\\n');\n          this.displayPrompt();\n          lines.forEach(function (line) {\n            if (line) {\n              self.rli.write(line + '\\n');\n            }\n          });\n        }\n      } catch (e) {\n        this.outputStream.write('Failed to load:' + file + '\\n');\n      }\n      this.displayPrompt();\n    }\n  });\n}\n\n\nfunction trimWhitespace(cmd) {\n  var trimmer = /^\\s*(.+)\\s*$/m,\n      matches = trimmer.exec(cmd);\n\n  if (matches && matches.length === 2) {\n    return matches[1];\n  }\n}\n\n\nfunction regexpEscape(s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n}\n\n\n/**\n * Converts commands that use var and function <name>() to use the\n * local exports.context when evaled. This provides a local context\n * on the REPL.\n *\n * @param {String} cmd The cmd to convert.\n * @return {String} The converted command.\n */\nREPLServer.prototype.convertToContext = function(cmd) {\n  var self = this, matches,\n      scopeVar = /^\\s*var\\s*([_\\w\\$]+)(.*)$/m,\n      scopeFunc = /^\\s*function\\s*([_\\w\\$]+)/;\n\n  // Replaces: var foo = \"bar\";  with: self.context.foo = bar;\n  matches = scopeVar.exec(cmd);\n  if (matches && matches.length === 3) {\n    return 'self.context.' + matches[1] + matches[2];\n  }\n\n  // Replaces: function foo() {};  with: foo = function foo() {};\n  matches = scopeFunc.exec(self.bufferedCommand);\n  if (matches && matches.length === 2) {\n    return matches[1] + ' = ' + self.bufferedCommand;\n  }\n\n  return cmd;\n};\n})", "gear:repl")(exports, require, module);
}
static NativeModule _module_repl("repl", _setup_repl);