license {
    // Copyright (c) 2011 the gearbox-node project authors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
}

top {
#ifdef _WIN32
    #include <winsock.h>
#else
    #include <unistd.h>
    #include <fcntl.h>
    #include <netdb.h>
    #include <netinet/in.h>
    #include <sys/socket.h>
#endif
}

module Network {
    class Socket {
        var socket = -1;
        var family = -1;
        var type = -1;
        var isConnected = false;
        
        function Socket(family, type) {
            int sock = socket(family, type, 0);
            if(sock == -1)
                THROW_ERROR("Unable to create socket");
            
            this["socket"] = Internal(sock);
            this["family"] = Internal(family);
            this["type"] = Internal(type);
        }
        
        function connect(host, port) {
            struct hostent *host_s = gethostbyname(host.to<String>());
            if(!host_s)
                THROW_ERROR("Unable to resolve host");
                
            struct sockaddr_in server_addr;
            server_addr.sin_family = this["family"].to<uint32_t>();
            server_addr.sin_port = htons(port.to<uint32_t>());
            server_addr.sin_addr = *((struct in_addr *)host_s->h_addr);
            
            int result = connect(this["socket"], (struct sockaddr *)&server_addr, sizeof(struct sockaddr));
            if(result == -1)
                THROW_ERROR("Unable to connect");
            
            this["isConnected"] = Internal(true);
        }
        
        function receive() {
            int maxLen = Value(args[0]) == undefined ? 1024 : Value(args[0]).to<int>();
            char *buffer = new char [maxLen];
            int len = recv(this["socket"], buffer, maxLen, 0);
            if(len > 0) {
                String str(buffer, len);
                delete [] buffer;
                return str;
            }
            delete [] buffer;
        }
        
        function send(data) {
            send(this["socket"], data.to<String>(), data.length(), 0);
        }
        
        function close() {
#ifdef _WIN32
            closesocket(this["socket"]);
#else
            close(this["socket"]);
#endif
        }
        
        function block(blocking) {
#ifdef _WIN32
            u_long mode = blocking ? 1 : 0;
            ioctlsocket(this["socket"], FIONBIO, &mode);
#else
            int mode = fcntl(this["socket"], F_GETFL, 0);
            if(blocking)
                mode &= ~O_NONBLOCK;
            else
                mode |= O_NONBLOCK;
            fcntl(this["socket"], F_SETFL, mode);
#endif
        }
        
        /** Constants */
        
        /** Socket families */
        static var INet = AF_INET;
        /*static var INET6 = AF_INET6;*/
        static var Unix = AF_UNIX;
        
        /** Socket types */
        static var Tcp = SOCK_STREAM;
        static var Udp = SOCK_DGRAM;
    }
}
