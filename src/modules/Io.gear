license {
    /*
     * Copyright (c) 2011 Eduard Burtescu
     *
     * Permission to use, copy, modify, and distribute this software for any
     * purpose with or without fee is hereby granted, provided that the above
     * copyright notice and this permission notice appear in all copies.
     *
     * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
     * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
     * MERCHANTABILITY AND FITRTLSS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
     * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
     * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
     * ACTION OF CONTRACT, RTLGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
     * OR IN CONRTLCTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
     */
}

top {
    #include <fstream>
    
    #define _THIS_FSTREAM (This["fstream"].to<std::fstream*>())
    
    #define _FSTREAM_READ(x, i, dw) do {x i;_THIS_FSTREAM->read(reinterpret_cast<char*>(&i), sizeof(x));dw;} while(0)
    //printf("Error while reading an %s: %s\n", #x, strerror(errno));
}

module Io {
    class Stream {
        var fstream = 0;
        
        function Stream(path) {
            this["fstream"] = new std::fstream(path.to<String>());
        }
        
        function Stream(path, mode) {
            std::ios_base::openmode openMode = static_cast<std::ios_base::openmode>(0);
            if(mode.is<Object>()) {
                if(mode["in"])
                    openMode |= std::fstream::in;
                if(mode["out"])
                    openMode |= std::fstream::out;
                if(mode["binary"])
                    openMode |= std::fstream::binary;
                if(mode["append"])
                    openMode |= std::fstream::app;
            } else {
                String modeString = mode;
                char *modeChar = modeString;
                while(*modeChar) {
                    if(*modeChar == 'r')
                        openMode |= std::fstream::in;
                    if(*modeChar == 'w')
                        openMode |= std::fstream::out;
                    if(*modeChar == 'b')
                        openMode |= std::fstream::binary;
                    if(*modeChar == '+')
                        openMode |= std::fstream::app;
                    modeChar++;
                }
            }
            this["fstream"] = new std::fstream(path.to<String>(), openMode);
            //printf("Error while openning %s: %s %i\n", *(path.to<String>()), strerror(errno), openMode);
        }
        
        function tellg() {
            return Integer(_THIS_FSTREAM->tellg());
        }
        
        function seekg(pos) {
            _THIS_FSTREAM->seekg(pos.to<int>());
            //printf("Error while seeking to %i: %s\n", pos.to<int>(), strerror(errno));
        }
        
        function seekg(off, dir) {
            _THIS_FSTREAM->seekg(off, static_cast<std::ios_base::seekdir>(dir.to<int>()));
        }
        
        function readInt(len) {
            if(len == 1)
                _FSTREAM_READ(uint8_t, i, return Integer(i));
            if(len == 2)
                _FSTREAM_READ(uint16_t, i, return Integer(i));
            if(len == 4)
                _FSTREAM_READ(uint32_t, i, return Integer(i));
            if(len == 8)
                _FSTREAM_READ(uint64_t, i, return Integer(i));
        }
        
        function readFloat() {
            _FSTREAM_READ(float, f, return Number(f));
        }
        
        function readFloat(prec) {
            if(prec == 1)
                _FSTREAM_READ(float, f, return Number(f));
            if(prec == 2)
                _FSTREAM_READ(double, f, return Number(f));
            if(prec == 4)
                _FSTREAM_READ(long double, f, return Number(f));
        }
        
        function tellp() {
            return Integer(_THIS_FSTREAM->tellp());
        }
        
        function seekp(pos) {
            _THIS_FSTREAM->seekp(pos.to<int>());
        }
        
        function seekp(off, dir) {
            _THIS_FSTREAM->seekp(off, static_cast<std::ios_base::seekdir>(dir.to<int>()));
        }
        
        function close() {
            _THIS_FSTREAM->close();
        }
    }
    
    var SEEK_BEG = std::ios_base::beg;
    var SEEK_CUR = std::ios_base::cur;
    var SEEK_END = std::ios_base::end;
    
    function read(path) {
        std::ifstream file(path.to<String>(), std::ifstream::in | std::ifstream::binary);
        if(!file.good())
            return;
        
        file.seekg(0, std::ios::end);
        size_t length = file.tellg();
        file.seekg(0, std::ios::beg);
        
        char *pBuffer = new char [length];
        
        file.read(pBuffer, length);
        String contents(pBuffer, length);
        
        delete [] pBuffer;
        return contents;
    }
    
    function write(path, contents) {
        std::ofstream file(path.to<String>());
        file.write(contents.to<String>(), contents.length());
    }
}
