#line 1 "src/modules/net.gear"

// Copyright Joyent, Inc. and other Node contributors.
//           (c) 2011 the gearbox-node project authors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

#include <gearbox.h>

using namespace Gearbox;

/** \file src/modules/net.cc converted from src/modules/net.gear */



#line 33 "src/modules/net.cc"
static void _setup_net(Value exports, Value require, Value module) {
    Context::getCurrent()->runScript("(function(exports, require, module){\n//BEGIN lib/net.js\nvar events = require('events');\nvar stream = require('stream');\nvar timers = require('timers');\nvar util = require('util');\nvar assert = require('assert');\n\nfunction noop() {};\n\n// constructor for lazy loading\nfunction createPipe() {\n//BEGIN *gearbox\n  //var Pipe = process.binding('pipe_wrap').Pipe;\n  var Pipe = require('pipe').Pipe;\n//END *gearbox\n  return new Pipe();\n}\n\n// constructor for lazy loading\nfunction createTCP() {\n//BEGIN *gearbox\n  //var TCP = process.binding('tcp_wrap').TCP;\n  var TCP = tcp_wrap.TCP;\n//END *gearbox\n  return new TCP();\n}\n\n\n/* Bit flags for socket._flags */\nvar FLAG_GOT_EOF = 1 << 0;\nvar FLAG_SHUTDOWN = 1 << 1;\nvar FLAG_DESTROY_SOON = 1 << 2;\nvar FLAG_SHUTDOWNQUED = 1 << 3;\n\n\nvar debug;\nif (process.env.NODE_DEBUG && /net/.test(process.env.NODE_DEBUG)) {\n  debug = function(x) { console.error('NET:', x); };\n} else {\n  debug = function() { };\n}\n\n\nfunction isPipeName(s) {\n  return typeof s === 'string' && toPort(s) === false;\n}\n\n\nexports.createServer = function() {\n  return new Server(arguments[0], arguments[1]);\n};\n\n\nexports.connect = exports.createConnection = function(port /* [host], [cb] */) {\n  var s;\n\n  if (isPipeName(port)) {\n    s = new Socket({ handle: createPipe() });\n  } else {\n    s = new Socket();\n  }\n\n  return s.connect(port, arguments[1], arguments[2]);\n};\n\n/* called when creating new Socket, or when re-using a closed Socket */\nfunction initSocketHandle(self) {\n  self._pendingWriteReqs = 0;\n\n  self._flags = 0;\n  self._connectQueueSize = 0;\n  self.destroyed = false;\n  self.bytesRead = 0;\n  self.bytesWritten = 0;\n\n  // Handle creation may be deferred to bind() or connect() time.\n  if (self._handle) {\n    self._handle.socket = self;\n    self._handle.onread = onread;\n  }\n}\n\nfunction Socket(options) {\n  if (!(this instanceof Socket)) return new Socket(options);\n\n  stream.Stream.call(this);\n\n  if (typeof options == 'number') {\n    // Legacy interface.\n    // Must support legacy interface. NPM depends on it.\n    // https://github.com/isaacs/npm/blob/c7824f412f0cb59d6f55cf0bc220253c39e6029f/lib/utils/output.js#L110\n    var fd = options;\n\n    // Uncomment the following lines after libuv backend is stable and API\n    // compatibile with legaacy.\n    //   console.error('Deprecated interface net.Socket(fd).');\n    //   console.trace();\n    this._handle = createPipe();\n    this._handle.open(fd);\n    this.readable = this.writable = true;\n    initSocketHandle(this);\n  } else {\n    // private\n    this._handle = options && options.handle;\n    initSocketHandle(this);\n    this.allowHalfOpen = options && options.allowHalfOpen;\n  }\n}\nutil.inherits(Socket, stream.Stream);\n\n\nexports.Socket = Socket;\nexports.Stream = Socket; // Legacy naming.\n\n\nSocket.prototype.listen = function() {\n  var self = this;\n  self.on('connection', arguments[0]);\n  listen(self, null, null);\n};\n\n\nSocket.prototype.setTimeout = function(msecs, callback) {\n  if (msecs > 0) {\n    timers.enroll(this, msecs);\n    timers.active(this);\n    if (callback) {\n      this.once('timeout', callback);\n    }\n  } else if (msecs === 0) {\n    timers.unenroll(this);\n  }\n};\n\n\nSocket.prototype._onTimeout = function() {\n  this.emit('timeout');\n};\n\n\nSocket.prototype.setNoDelay = function() {\n  if (this._handle && this._handle.setNoDelay)\n    this._handle.setNoDelay();\n};\n\n\nSocket.prototype.setKeepAlive = function(setting, msecs) {\n  if (this._handle && this._handle.setKeepAlive)\n    this._handle.setKeepAlive(setting, ~~(msecs / 1000));\n};\n\n\nSocket.prototype.address = function() {\n  return this._handle.getsockname();\n};\n\n\nObject.defineProperty(Socket.prototype, 'readyState', {\n  get: function() {\n    if (this._connecting) {\n      return 'opening';\n    } else if (this.readable && this.writable) {\n      return 'open';\n    } else if (this.readable && !this.writable) {\n      return 'readOnly';\n    } else if (!this.readable && this.writable) {\n      return 'writeOnly';\n    } else {\n      return 'closed';\n    }\n  }\n});\n\n\nObject.defineProperty(Socket.prototype, 'bufferSize', {\n  get: function() {\n    return this._handle.writeQueueSize + this._connectQueueSize;\n  }\n});\n\n\nSocket.prototype.pause = function() {\n  this._handle.readStop();\n};\n\n\nSocket.prototype.resume = function() {\n  if (this._handle) {\n    this._handle.readStart();\n  }\n};\n\n\nSocket.prototype.end = function(data, encoding) {\n  if (this._connecting && ((this._flags & FLAG_SHUTDOWNQUED) == 0)) {\n    // still connecting, add data to buffer\n    if (data) this.write(data, encoding);\n    this.writable = false;\n    this._flags |= FLAG_SHUTDOWNQUED;\n  }\n\n  if (!this.writable) return;\n  this.writable = false;\n\n  if (data) this.write(data, encoding);\n  DTRACE_NET_STREAM_END(this);\n\n  if (!this.readable) {\n    this.destroySoon();\n  } else {\n    this._flags |= FLAG_SHUTDOWN;\n    var shutdownReq = this._handle.shutdown();\n\n    if (!shutdownReq) {\n      this.destroy(errnoException(errno, 'shutdown'));\n      return false;\n    }\n\n    shutdownReq.oncomplete = afterShutdown;\n  }\n\n  return true;\n};\n\n\nfunction afterShutdown(status, handle, req) {\n  var self = handle.socket;\n\n  assert.ok(self._flags & FLAG_SHUTDOWN);\n  assert.ok(!self.writable);\n\n  // callback may come after call to destroy.\n  if (self.destroyed) {\n    return;\n  }\n\n  if (self._flags & FLAG_GOT_EOF || !self.readable) {\n    self.destroy();\n  } else {\n  }\n}\n\n\nSocket.prototype.destroySoon = function() {\n  this.writable = false;\n  this._flags |= FLAG_DESTROY_SOON;\n\n  if (this._pendingWriteReqs == 0) {\n    this.destroy();\n  }\n};\n\n\nSocket.prototype._connectQueueCleanUp = function(exception) {\n  this._connecting = false;\n  this._connectQueueSize = 0;\n  this._connectQueue = null;\n};\n\n\nSocket.prototype.destroy = function(exception) {\n  var self = this;\n\n  self._connectQueueCleanUp();\n\n  debug('destroy');\n\n  this.readable = this.writable = false;\n\n  timers.unenroll(this);\n\n  if (this.server && !this.destroyed) {\n    this.server.connections--;\n    this.server._emitCloseIfDrained();\n  }\n\n  debug('close');\n  if (this._handle) {\n    this._handle.close();\n    this._handle.onread = noop;\n    this._handle = null;\n  }\n\n  process.nextTick(function() {\n    if (exception) self.emit('error', exception);\n    self.emit('close', exception ? true : false);\n  });\n\n  this.destroyed = true;\n};\n\n\nfunction onread(buffer, offset, length) {\n  var handle = this;\n  var self = handle.socket;\n  assert.equal(handle, self._handle);\n\n  timers.active(self);\n\n  var end = offset + length;\n\n  if (buffer) {\n    // Emit 'data' event.\n\n    if (self._decoder) {\n      // Emit a string.\n      var string = self._decoder.write(buffer.slice(offset, end));\n      if (string.length) self.emit('data', string);\n    } else {\n      // Emit a slice. Attempt to avoid slicing the buffer if no one is\n      // listening for 'data'.\n      if (self._events && self._events['data']) {\n        self.emit('data', buffer.slice(offset, end));\n      }\n    }\n\n    self.bytesRead += length;\n\n    // Optimization: emit the original buffer with end points\n    if (self.ondata) self.ondata(buffer, offset, end);\n\n  } else if (errno == 'EOF') {\n    // EOF\n    self.readable = false;\n\n    assert.ok(!(self._flags & FLAG_GOT_EOF));\n    self._flags |= FLAG_GOT_EOF;\n\n    // We call destroy() before end(). 'close' not emitted until nextTick so\n    // the 'end' event will come first as required.\n    if (!self.writable) self.destroy();\n\n    if (!self.allowHalfOpen) self.end();\n    if (self._events && self._events['end']) self.emit('end');\n    if (self.onend) self.onend();\n  } else {\n    // Error\n    if (errno == 'ECONNRESET') {\n      self.destroy();\n    } else {\n      self.destroy(errnoException(errno, 'read'));\n    }\n  }\n}\n\n\nSocket.prototype.setEncoding = function(encoding) {\n  var StringDecoder = require('string_decoder').StringDecoder; // lazy load\n  this._decoder = new StringDecoder(encoding);\n};\n\n\nSocket.prototype._getpeername = function() {\n  if (!this._handle || !this._handle.getpeername) {\n    return {};\n  }\n  if (!this._peername) {\n    this._peername = this._handle.getpeername();\n  }\n  return this._peername;\n};\n\n\nSocket.prototype.__defineGetter__('remoteAddress', function() {\n  return this._getpeername().address;\n});\n\n\nSocket.prototype.__defineGetter__('remotePort', function() {\n  return this._getpeername().port;\n});\n\n\n/*\n * Arguments data, [encoding], [cb]\n */\nSocket.prototype.write = function(data, arg1, arg2) {\n  var encoding, cb;\n\n  // parse arguments\n  if (arg1) {\n    if (typeof arg1 === 'string') {\n      encoding = arg1;\n      cb = arg2;\n    } else if (typeof arg1 === 'function') {\n      cb = arg1;\n    } else {\n      throw new Error(\"bad arg\");\n    }\n  }\n\n  // Change strings to buffers. SLOW\n  if (typeof data == 'string') {\n    data = new Buffer(data, encoding);\n  }\n\n  this.bytesWritten += data.length;\n\n  // If we are still connecting, then buffer this for later.\n  if (this._connecting) {\n    this._connectQueueSize += data.length;\n    if (this._connectQueue) {\n      this._connectQueue.push([data, encoding, cb]);\n    } else {\n      this._connectQueue = [[data, encoding, cb]];\n    }\n    return false;\n  }\n\n  return this._write(data, encoding, cb);\n};\n\n\nSocket.prototype._write = function(data, encoding, cb) {\n  timers.active(this);\n\n  // `encoding` is unused right now, `data` is always a buffer.\n  var writeReq = this._handle.write(data);\n\n  if (!writeReq) {\n    this.destroy(errnoException(errno, 'write'));\n    return false;\n  }\n\n  writeReq.oncomplete = afterWrite;\n  writeReq.cb = cb;\n  this._pendingWriteReqs++;\n\n  return this._handle.writeQueueSize == 0;\n};\n\n\nfunction afterWrite(status, handle, req, buffer) {\n  var self = handle.socket;\n\n  // callback may come after call to destroy.\n  if (self.destroyed) {\n    return;\n  }\n  // TODO check status.\n\n  timers.active(this);\n\n  self._pendingWriteReqs--;\n\n  if (self._pendingWriteReqs == 0) {\n    // TODO remove all uses of ondrain - this is not a good hack.\n    if (self.ondrain) self.ondrain();\n    self.emit('drain');\n  }\n\n  if (req.cb) req.cb();\n\n  if (self._pendingWriteReqs == 0 && self._flags & FLAG_DESTROY_SOON) {\n    self.destroy();\n  }\n}\n\n\nfunction connect(self, address, port, addressType) {\n  if (port) {\n    self.remotePort = port;\n  }\n  self.remoteAddress = address;\n\n  // TODO return promise from Socket.prototype.connect which\n  // wraps _connectReq.\n\n  assert.ok(self._connecting);\n\n  var connectReq;\n  if (addressType == 6) {\n    connectReq = self._handle.connect6(address, port);\n  } else if (addressType == 4) {\n    connectReq = self._handle.connect(address, port);\n  } else {\n    connectReq = self._handle.connect(address, afterConnect);\n  }\n\n  if (connectReq !== null) {\n    connectReq.oncomplete = afterConnect;\n  } else {\n    self.destroy(errnoException(errno, 'connect'));\n  }\n}\n\n\nSocket.prototype.connect = function(port /* [host], [cb] */) {\n  var self = this;\n\n  var pipe = isPipeName(port);\n\n  if (this.destroyed || !this._handle) {\n    this._handle = pipe ? createPipe() : createTCP();\n    initSocketHandle(this);\n  }\n\n  var host;\n  if (typeof arguments[1] === 'function') {\n    self.on('connect', arguments[1]);\n  } else {\n    host = arguments[1];\n    if (typeof arguments[2] === 'function') {\n      self.on('connect', arguments[2]);\n    }\n  }\n\n  timers.active(this);\n\n  self._connecting = true;\n  self.writable = true;\n\n  if (pipe) {\n    connect(self, /*pipe_name=*/port);\n\n  } else if (typeof host == 'string') {\n    debug('connect: find host ' + host);\n    require('dns').lookup(host, function(err, ip, addressType) {\n      // It's possible we were destroyed while looking this up.\n      // XXX it would be great if we could cancel the promise returned by\n      // the look up.\n      if (!self._connecting) return;\n\n      if (err) {\n        // net.createConnection() creates a net.Socket object and\n        // immediately calls net.Socket.connect() on it (that's us).\n        // There are no event listeners registered yet so defer the\n        // error event to the next tick.\n        process.nextTick(function() {\n          self.emit('error', err);\n        });\n      } else {\n        timers.active(self);\n\n        addressType = addressType || 4;\n\n        // node_net.cc handles null host names graciously but user land\n        // expects remoteAddress to have a meaningful value\n        ip = ip || (addressType === 4 ? '127.0.0.1' : '0:0:0:0:0:0:0:1');\n\n        connect(self, ip, port, addressType);\n      }\n    });\n\n  } else {\n    debug('connect: missing host');\n    connect(self, '127.0.0.1', port, 4);\n  }\n  return self;\n};\n\n\nfunction afterConnect(status, handle, req) {\n  var self = handle.socket;\n\n  // callback may come after call to destroy\n  if (self.destroyed) {\n    return;\n  }\n\n  assert.equal(handle, self._handle);\n\n  debug('afterConnect');\n\n  assert.ok(self._connecting);\n  self._connecting = false;\n\n  if (status == 0) {\n    self.readable = self.writable = true;\n    timers.active(self);\n\n    handle.readStart();\n\n    self.emit('connect');\n\n    if (self._connectQueue) {\n      debug('Drain the connect queue');\n      for (var i = 0; i < self._connectQueue.length; i++) {\n        self._write.apply(self, self._connectQueue[i]);\n      }\n      self._connectQueueCleanUp();\n    }\n\n    if (self._flags & FLAG_SHUTDOWNQUED) {\n      // end called before connected - call end now with no data\n      self._flags &= ~FLAG_SHUTDOWNQUED;\n      self.end();\n    }\n  } else {\n    self._connectQueueCleanUp();\n    self.destroy(errnoException(errno, 'connect'));\n  }\n}\n\n\nfunction errnoException(errorno, syscall) {\n  // TODO make this more compatible with ErrnoException from src/node.cc\n  // Once all of Node is using this function the ErrnoException from\n  // src/node.cc should be removed.\n  var e = new Error(syscall + ' ' + errorno);\n  e.errno = e.code = errorno;\n  e.syscall = syscall;\n  return e;\n}\n\n\n\n\nfunction Server(/* [ options, ] listener */) {\n  if (!(this instanceof Server)) return new Server(arguments[0], arguments[1]);\n  events.EventEmitter.call(this);\n\n  var self = this;\n\n  var options;\n\n  if (typeof arguments[0] == 'function') {\n    options = {};\n    self.on('connection', arguments[0]);\n  } else {\n    options = arguments[0] || {};\n\n    if (typeof arguments[1] == 'function') {\n      self.on('connection', arguments[1]);\n    }\n  }\n\n  this.connections = 0;\n  this.allowHalfOpen = options.allowHalfOpen || false;\n\n  this._handle = null;\n}\nutil.inherits(Server, events.EventEmitter);\nexports.Server = Server;\n\n\nfunction toPort(x) { return (x = Number(x)) >= 0 ? x : false; }\n\n\nvar createServerHandle = exports._createServerHandle =\n    function(address, port, addressType) {\n  var r = 0;\n  // assign handle in listen, and clean up if bind or listen fails\n  var handle =\n      (port == -1 && addressType == -1) ? createPipe() : createTCP();\n\n  if (address || port) {\n    debug('bind to ' + address);\n    if (addressType == 6) {\n      r = handle.bind6(address, port);\n    } else {\n      r = handle.bind(address, port);\n    }\n  }\n\n  if (r) {\n    handle.close();\n    handle = null;\n  }\n\n  return handle;\n};\n\n\nServer.prototype._listen2 = function(address, port, addressType) {\n  var self = this;\n  var r = 0;\n\n  // If there is not yet a handle, we need to create one and bind.\n  // In the case of a server sent via IPC, we don't need to do this.\n  if (!self._handle) {\n    self._handle = createServerHandle(address, port, addressType);\n    if (!self._handle) {\n      process.nextTick(function() {\n        self.emit('error', errnoException(errno, 'listen'));\n      });\n      return;\n    }\n  }\n\n  self._handle.onconnection = onconnection;\n  self._handle.socket = self;\n\n  r = self._handle.listen(self._backlog || 128);\n\n  if (r) {\n    self._handle.close();\n    self._handle = null;\n    process.nextTick(function() {\n      self.emit('error', errnoException(errno, 'listen'));\n    });\n    return;\n  }\n\n  process.nextTick(function() {\n    self.emit('listening');\n  });\n}\n\n\nfunction listen(self, address, port, addressType) {\n  if (process.env.NODE_WORKER_ID) {\n    require('cluster').getServer(address, port, addressType, function(handle) {\n      self._handle = handle;\n      self._listen2(address, port, addressType);\n    });\n  } else {\n    self._listen2(address, port, addressType);\n  }\n}\n\n\nServer.prototype.listen = function() {\n  var self = this;\n\n  var lastArg = arguments[arguments.length - 1];\n  if (typeof lastArg == 'function') {\n    self.once('listening', lastArg);\n  }\n\n  var port = toPort(arguments[0]);\n\n  var TCP = process.binding('tcp_wrap').TCP;\n\n  if (arguments.length == 0 || typeof arguments[0] == 'function') {\n    // Don't bind(). OS will assign a port with INADDR_ANY.\n    // The port can be found with server.address()\n    listen(self, null, null);\n\n  } else if (arguments[0] instanceof TCP) {\n    self._handle = arguments[0];\n    listen(self, null, -1, -1);\n\n  } else if (isPipeName(arguments[0])) {\n    // UNIX socket or Windows pipe.\n    var pipeName = self._pipeName = arguments[0];\n    listen(self, pipeName, -1, -1);\n\n  } else if (typeof arguments[1] == 'undefined' ||\n             typeof arguments[1] == 'function') {\n    // The first argument is the port, no IP given.\n    listen(self, '0.0.0.0', port, 4);\n\n  } else {\n    // The first argument is the port, the second an IP\n    require('dns').lookup(arguments[1], function(err, ip, addressType) {\n      if (err) {\n        self.emit('error', err);\n      } else {\n        listen(self, ip || '0.0.0.0', port, ip ? addressType : 4);\n      }\n    });\n  }\n  return self;\n};\n\nServer.prototype.address = function() {\n  if (this._handle && this._handle.getsockname) {\n    return this._handle.getsockname();\n  } else if (this._pipeName) {\n    return this._pipeName;\n  } else {\n    return null;\n  }\n};\n\nfunction onconnection(clientHandle) {\n  var handle = this;\n  var self = handle.socket;\n\n  debug('onconnection');\n\n  if (!clientHandle) {\n    self.emit('error', errnoException(errno, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self.connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  var socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen\n  });\n  socket.readable = socket.writable = true;\n\n  socket.resume();\n\n  self.connections++;\n  socket.server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n  socket.emit('connect');\n}\n\n\nServer.prototype.close = function() {\n  if (!this._handle) {\n    // Throw error. Follows net_legacy behaviour.\n    throw new Error('Not running');\n  }\n\n  this._handle.close();\n  this._handle = null;\n  this._emitCloseIfDrained();\n\n  return this;\n};\n\nServer.prototype._emitCloseIfDrained = function() {\n  if (!this._handle && !this.connections) {\n    this.emit('close');\n  }\n};\n\n\nServer.prototype.listenFD = function(fd, type) {\n  throw new Error('This API is no longer supported. See child_process.fork');\n};\n\n\n// TODO: isIP should be moved to the DNS code. Putting it here now because\n// this is what the legacy system did.\n// NOTE: This does not accept IPv6 with an IPv4 dotted address at the end,\n//  and it does not detect more than one double : in a string.\nexports.isIP = function(input) {\n  if (!input) {\n    return 4;\n  } else if (/^(\\d?\\d?\\d)\\.(\\d?\\d?\\d)\\.(\\d?\\d?\\d)\\.(\\d?\\d?\\d)$/.test(input)) {\n    var parts = input.split('.');\n    for (var i = 0; i < parts.length; i++) {\n      var part = parseInt(parts[i]);\n      if (part < 0 || 255 < part) {\n        return 0;\n      }\n    }\n    return 4;\n  } else if (/^::|^::1|^([a-fA-F0-9]{1,4}::?){1,7}([a-fA-F0-9]{1,4})$/.test(\n      input)) {\n    return 6;\n  } else {\n    return 0;\n  }\n};\n\n\nexports.isIPv4 = function(input) {\n  return exports.isIP(input) === 4;\n};\n\n\nexports.isIPv6 = function(input) {\n  return exports.isIP(input) === 6;\n};\n//END lib/net.js\n    })", "gear:net")(exports, require, module);
}
static NativeModule _module_net("net", _setup_net);