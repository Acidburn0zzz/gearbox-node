// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

#include <gearbox.h>

using namespace Gearbox;

/** \file src/modules/_debugger.cc converted from src/modules/_debugger.js */



#line 30 "src/modules/_debugger.cc"
static void _setup__debugger(Value exports, Value require, Value module) {
    Context::getCurrent()->runScript("(function(exports, require, module){\n\nvar util = require('util'),\n    path = require('path'),\n    net = require('net'),\n    vm = require('vm'),\n    repl = require('repl'),\n    inherits = util.inherits,\n    spawn = require('child_process').spawn;\n\nexports.start = function(argv, stdin, stdout) {\n  argv || (argv = process.argv.slice(2));\n\n  if (argv.length < 1) {\n    console.error('Usage: node debug script.js');\n    process.exit(1);\n  }\n\n  // Setup input/output streams\n  stdin = stdin || process.openStdin();\n  stdout = stdout || process.stdout;\n\n  var args = ['--debug-brk'].concat(argv),\n      interface = new Interface(stdin, stdout, args);\n\n  stdin.resume();\n\n  process.on('uncaughtException', function(e) {\n    console.error(\"There was an internal error in Node's debugger. \" +\n        'Please report this bug.');\n    console.error(e.message);\n    console.error(e.stack);\n    if (interface.child) interface.child.kill();\n    process.exit(1);\n  });\n};\n\nexports.port = 5858;\n\n\n//\n// Parser/Serializer for V8 debugger protocol\n// http://code.google.com/p/v8/wiki/DebuggerProtocol\n//\n// Usage:\n//    p = new Protocol();\n//\n//    p.onResponse = function(res) {\n//      // do stuff with response from V8\n//    };\n//\n//    socket.setEncoding('utf8');\n//    socket.on('data', function(s) {\n//      // Pass strings into the protocol\n//      p.execute(s);\n//    });\n//\n//\nfunction Protocol() {\n  this._newRes();\n}\nexports.Protocol = Protocol;\n\n\nProtocol.prototype._newRes = function(raw) {\n  this.res = { raw: raw || '', headers: {} };\n  this.state = 'headers';\n  this.reqSeq = 1;\n  this.execute('');\n};\n\n\nProtocol.prototype.execute = function(d) {\n  var res = this.res;\n  res.raw += d;\n\n  switch (this.state) {\n    case 'headers':\n      var endHeaderIndex = res.raw.indexOf('\\r\\n\\r\\n');\n\n      if (endHeaderIndex < 0) break;\n\n      var rawHeader = res.raw.slice(0, endHeaderIndex);\n      var endHeaderByteIndex = Buffer.byteLength(rawHeader, 'utf8');\n      var lines = rawHeader.split('\\r\\n');\n      for (var i = 0; i < lines.length; i++) {\n        var kv = lines[i].split(/: +/);\n        res.headers[kv[0]] = kv[1];\n      }\n\n      this.contentLength = +res.headers['Content-Length'];\n      this.bodyStartByteIndex = endHeaderByteIndex + 4;\n\n      this.state = 'body';\n\n      if (Buffer.byteLength(res.raw, 'utf8') - this.bodyStartByteIndex\n          < this.contentLength) {\n        break;\n      }\n      // pass thru\n    case 'body':\n      var resRawByteLength = Buffer.byteLength(res.raw, 'utf8');\n\n      if (resRawByteLength - this.bodyStartByteIndex >= this.contentLength) {\n        var buf = new Buffer(resRawByteLength);\n        buf.write(res.raw, 0, resRawByteLength, 'utf8');\n        res.body =\n            buf.slice(this.bodyStartByteIndex,\n                      this.bodyStartByteIndex\n                      + this.contentLength).toString('utf8');\n        // JSON parse body?\n        res.body = res.body.length ? JSON.parse(res.body) : {};\n\n        // Done!\n        this.onResponse(res);\n\n        this._newRes(buf.slice(this.bodyStartByteIndex\n                               + this.contentLength).toString('utf8'));\n      }\n      break;\n\n    default:\n      throw new Error('Unknown state');\n      break;\n  }\n};\n\n\nProtocol.prototype.serialize = function(req) {\n  req.type = 'request';\n  req.seq = this.reqSeq++;\n  var json = JSON.stringify(req);\n  return 'Content-Length: ' + Buffer.byteLength(json,'utf8') + '\\r\\n\\r\\n'\n      + json;\n};\n\n\nvar NO_FRAME = -1;\n\nfunction Client() {\n  net.Stream.call(this);\n  var protocol = this.protocol = new Protocol(this);\n  this._reqCallbacks = [];\n  var socket = this;\n\n  this.currentFrame = NO_FRAME;\n  this.currentSourceLine = -1;\n  this.currentSource = null;\n  this.handles = {};\n  this.scripts = {};\n  this.breakpoints = [];\n\n  // Note that 'Protocol' requires strings instead of Buffers.\n  socket.setEncoding('utf8');\n  socket.on('data', function(d) {\n    protocol.execute(d);\n  });\n\n  protocol.onResponse = this._onResponse.bind(this);\n}\ninherits(Client, net.Stream);\nexports.Client = Client;\n\n\nClient.prototype._addHandle = function(desc) {\n  if (typeof desc != 'object' || typeof desc.handle != 'number') {\n    return;\n  }\n\n  this.handles[desc.handle] = desc;\n\n  if (desc.type == 'script') {\n    this._addScript(desc);\n  }\n};\n\n\nvar natives = process.binding('natives');\n\n\nClient.prototype._addScript = function(desc) {\n  this.scripts[desc.id] = desc;\n  if (desc.name) {\n    desc.isNative = (desc.name.replace('.js', '') in natives) ||\n                    desc.name == 'node.js';\n  }\n};\n\n\nClient.prototype._removeScript = function(desc) {\n  this.scripts[desc.id] = undefined;\n};\n\n\nClient.prototype._onResponse = function(res) {\n  var cb,\n      index = -1;\n\n  this._reqCallbacks.some(function(fn, i) {\n    if (fn.request_seq == res.body.request_seq) {\n      cb = fn;\n      index = i;\n      return true;\n    }\n  });\n\n  var self = this;\n  var handled = false;\n\n  if (res.headers.Type == 'connect') {\n    // Request a list of scripts for our own storage.\n    self.reqScripts();\n    self.emit('ready');\n    handled = true;\n\n  } else if (res.body && res.body.event == 'break') {\n    this.emit('break', res.body);\n    handled = true;\n\n  } else if (res.body && res.body.event == 'afterCompile') {\n    this._addHandle(res.body.body.script);\n    handled = true;\n\n  } else if (res.body && res.body.event == 'scriptCollected') {\n    // ???\n    this._removeScript(res.body.body.script);\n    handled = true;\n\n  }\n\n  if (cb) {\n    this._reqCallbacks.splice(index, 1);\n    handled = true;\n\n    var err = res.success === false && (res.message || true) ||\n              res.body.success === false && (res.body.message || true);\n    cb(err, res.body && res.body.body || res.body, res);\n  }\n\n  if (!handled) this.emit('unhandledResponse', res.body);\n};\n\n\nClient.prototype.req = function(req, cb) {\n  this.write(this.protocol.serialize(req));\n  cb.request_seq = req.seq;\n  this._reqCallbacks.push(cb);\n};\n\n\nClient.prototype.reqVersion = function(cb) {\n  cb = cb || function() {};\n  this.req({ command: 'version' } , function(err, body, res) {\n    if (err) return cb(err);\n    cb(null, res.body.body.V8Version, res.body.running);\n  });\n};\n\n\nClient.prototype.reqLookup = function(refs, cb) {\n  var self = this;\n\n  // TODO: We have a cache of handle's we've already seen in this.handles\n  // This can be used if we're careful.\n  var req = {\n    command: 'lookup',\n    arguments: {\n      handles: refs\n    }\n  };\n\n  cb = cb || function() {};\n  this.req(req, function(err, res) {\n    if (err) return cb(err);\n    for (var ref in res) {\n      if (typeof res[ref] == 'object') {\n        self._addHandle(res[ref]);\n      }\n    }\n\n    cb(null, res);\n  });\n};\n\nClient.prototype.reqScopes = function(cb) {\n  var self = this,\n      req = {\n        command: 'scopes',\n        arguments: {}\n      };\n\n  cb = cb || function() {};\n  this.req(req, function(err, res) {\n    if (err) return cb(err);\n    var refs = res.scopes.map(function(scope) {\n      return scope.object.ref;\n    });\n\n    self.reqLookup(refs, function(err, res) {\n      if (err) return cb(err);\n\n      var globals = Object.keys(res).map(function(key) {\n        return res[key].properties.map(function(prop) {\n          return prop.name;\n        });\n      });\n\n      cb(null, globals.reverse());\n    });\n  });\n};\n\n// This is like reqEval, except it will look up the expression in each of the\n// scopes associated with the current frame.\nClient.prototype.reqEval = function(expression, cb) {\n  var self = this;\n\n  if (this.currentFrame == NO_FRAME) {\n    // Only need to eval in global scope.\n    this.reqFrameEval(expression, NO_FRAME, cb);\n    return;\n  }\n\n  cb = cb || function() {};\n  // Otherwise we need to get the current frame to see which scopes it has.\n  this.reqBacktrace(function(err, bt) {\n    if (err || !bt.frames) {\n      // ??\n      return cb(null, {});\n    }\n\n    var frame = bt.frames[self.currentFrame];\n\n    var evalFrames = frame.scopes.map(function(s) {\n      if (!s) return;\n      var x = bt.frames[s.index];\n      if (!x) return;\n      return x.index;\n    });\n\n    self._reqFramesEval(expression, evalFrames, cb);\n  });\n};\n\n\n// Finds the first scope in the array in which the epxression evals.\nClient.prototype._reqFramesEval = function(expression, evalFrames, cb) {\n  if (evalFrames.length == 0) {\n    // Just eval in global scope.\n    this.reqFrameEval(expression, NO_FRAME, cb);\n    return;\n  }\n\n  var self = this;\n  var i = evalFrames.shift();\n\n  cb = cb || function() {};\n  this.reqFrameEval(expression, i, function(err, res) {\n    if (!err) return cb(null, res);\n    self._reqFramesEval(expression, evalFrames, cb);\n  });\n};\n\n\nClient.prototype.reqFrameEval = function(expression, frame, cb) {\n  var self = this;\n  var req = {\n    command: 'evaluate',\n    arguments: { expression: expression }\n  };\n\n  if (frame == NO_FRAME) {\n    req.arguments.global = true;\n  } else {\n    req.arguments.frame = frame;\n  }\n\n  cb = cb || function() {};\n  this.req(req, function(err, res) {\n    if (!err) self._addHandle(res);\n    cb(err, res);\n  });\n};\n\n\n// reqBacktrace(cb)\n// TODO: from, to, bottom\nClient.prototype.reqBacktrace = function(cb) {\n  this.req({ command: 'backtrace' } , cb);\n};\n\n\n// Returns an array of objects like this:\n//\n//   { handle: 11,\n//     type: 'script',\n//     name: 'node.js',\n//     id: 14,\n//     lineOffset: 0,\n//     columnOffset: 0,\n//     lineCount: 562,\n//     sourceStart: '(function(process) {\\n\\n  ',\n//     sourceLength: 15939,\n//     scriptType: 2,\n//     compilationType: 0,\n//     context: { ref: 10 },\n//     text: 'node.js (lines: 562)' }\n//\nClient.prototype.reqScripts = function(cb) {\n  var self = this;\n  cb = cb || function() {};\n\n  this.req({ command: 'scripts' } , function(err, res) {\n    if (err) return cb(err);\n\n    for (var i = 0; i < res.length; i++) {\n      self._addHandle(res[i]);\n    }\n    cb(null);\n  });\n};\n\n\nClient.prototype.reqContinue = function(cb) {\n  this.currentFrame = NO_FRAME;\n  this.req({ command: 'continue' }, cb);\n};\n\nClient.prototype.listbreakpoints = function(cb) {\n  this.req({ command: 'listbreakpoints' }, cb);\n};\n\nClient.prototype.setBreakpoint = function(req, cb) {\n  req = {\n    command: 'setbreakpoint',\n    arguments: req\n  };\n\n  this.req(req, cb);\n};\n\nClient.prototype.clearBreakpoint = function(req, cb) {\n  var req = {\n    command: 'clearbreakpoint',\n    arguments: req\n  };\n\n  this.req(req, cb);\n};\n\nClient.prototype.reqSource = function(from, to, cb) {\n  var req = {\n    command: 'source',\n    fromLine: from,\n    toLine: to\n  };\n\n  this.req(req, cb);\n};\n\n\n// client.next(1, cb);\nClient.prototype.step = function(action, count, cb) {\n  var req = {\n    command: 'continue',\n    arguments: { stepaction: action, stepcount: count }\n  };\n\n  this.currentFrame = NO_FRAME;\n  this.req(req, cb);\n};\n\n\nClient.prototype.mirrorObject = function(handle, depth, cb) {\n  var self = this;\n\n  var val;\n\n  if (handle.type == 'object') {\n    // The handle looks something like this:\n    // { handle: 8,\n    //   type: 'object',\n    //   className: 'Object',\n    //   constructorFunction: { ref: 9 },\n    //   protoObject: { ref: 4 },\n    //   prototypeObject: { ref: 2 },\n    //   properties: [ { name: 'hello', propertyType: 1, ref: 10 } ],\n    //   text: '#<an Object>' }\n\n    // For now ignore the className and constructor and prototype.\n    // TJ's method of object inspection would probably be good for this:\n    // https://groups.google.com/forum/?pli=1#!topic/nodejs-dev/4gkWBOimiOg\n\n    var propertyRefs = handle.properties.map(function(p) {\n      return p.ref;\n    });\n\n    cb = cb || function() {};\n    this.reqLookup(propertyRefs, function(err, res) {\n      if (err) {\n        console.error('problem with reqLookup');\n        cb(null, handle);\n        return;\n      }\n\n      var mirror,\n          waiting = 1;\n\n      if (handle.className == 'Array') {\n        mirror = [];\n      } else {\n        mirror = {};\n      }\n\n\n      var keyValues = [];\n      handle.properties.forEach(function(prop, i) {\n        var value = res[prop.ref];\n        var mirrorValue;\n        if (value) {\n          mirrorValue = value.value ? value.value : value.text;\n        } else {\n          mirrorValue = '[?]';\n        }\n\n\n        if (Array.isArray(mirror) &&\n            typeof prop.name != 'number') {\n          // Skip the 'length' property.\n          return;\n        }\n\n        keyValues[i] = {\n          name: prop.name,\n          value: mirrorValue\n        };\n        if (value && value.handle && depth > 0) {\n          waiting++;\n          self.mirrorObject(value, depth - 1, function(err, result) {\n            if (!err) keyValues[i].value = result;\n            waitForOthers();\n          });\n        }\n      });\n\n      waitForOthers();\n      function waitForOthers() {\n        if (--waiting === 0 && cb) {\n          keyValues.forEach(function(kv) {\n            mirror[kv.name] = kv.value;\n          });\n          cb(null, mirror);\n        }\n      };\n    });\n    return;\n  } else if (handle.type === 'function') {\n    val = function() {};\n  } else if (handle.type === 'null') {\n    val = null;\n  } else if (handle.value !== undefined) {\n    val = handle.value;\n  } else if (handle.type === 'undefined') {\n    val = undefined;\n  } else {\n    val = handle;\n  }\n  process.nextTick(function() {\n    cb(null, val);\n  });\n};\n\n\nClient.prototype.fullTrace = function(cb) {\n  var self = this;\n\n  cb = cb || function() {};\n  this.reqBacktrace(function(err, trace) {\n    if (err) return cb(err);\n    if (trace.totalFrames <= 0) return cb(Error('No frames'));\n\n    var refs = [];\n\n    for (var i = 0; i < trace.frames.length; i++) {\n      var frame = trace.frames[i];\n      // looks like this:\n      // { type: 'frame',\n      //   index: 0,\n      //   receiver: { ref: 1 },\n      //   func: { ref: 0 },\n      //   script: { ref: 7 },\n      //   constructCall: false,\n      //   atReturn: false,\n      //   debuggerFrame: false,\n      //   arguments: [],\n      //   locals: [],\n      //   position: 160,\n      //   line: 7,\n      //   column: 2,\n      //   sourceLineText: '  debugger;',\n      //   scopes: [ { type: 1, index: 0 }, { type: 0, index: 1 } ],\n      //   text: '#00 blah() /home/ryan/projects/node/test-debug.js l...' }\n      refs.push(frame.script.ref);\n      refs.push(frame.func.ref);\n      refs.push(frame.receiver.ref);\n    }\n\n    self.reqLookup(refs, function(err, res) {\n      if (err) return cb(err);\n\n      for (var i = 0; i < trace.frames.length; i++) {\n        var frame = trace.frames[i];\n        frame.script = res[frame.script.ref];\n        frame.func = res[frame.func.ref];\n        frame.receiver = res[frame.receiver.ref];\n      }\n\n      cb(null, trace);\n    });\n  });\n};\n\n\n\n\n\n\nvar commands = [\n  [\n    'run (r)',\n    'cont (c)',\n    'next (n)',\n    'step (s)',\n    'out (o)',\n    'backtrace (bt)',\n    'setBreakpoint (sb)',\n    'clearBreakpoint (cb)'\n  ],\n  [\n    'watch',\n    'unwatch',\n    'watchers',\n    'repl',\n    'restart',\n    'kill',\n    'list',\n    'scripts',\n    'breakpoints',\n    'version'\n  ]\n];\n\n\nvar helpMessage = 'Commands: ' + commands.map(function(group) {\n  return group.join(', ');\n}).join(',\\n');\n\n\nfunction SourceUnderline(sourceText, position, tty) {\n  if (!sourceText) return '';\n\n  var head = sourceText.slice(0, position),\n      tail = sourceText.slice(position);\n\n  // Colourize char if stdout supports colours\n  if (tty && !repl.disableColors) {\n    tail = tail.replace(/(.+?)([^\\w]|$)/, '\\033[32m$1\\033[39m$2');\n  }\n\n  // Return source line with coloured char at `position`\n  return [\n    head,\n    tail\n  ].join('');\n}\n\n\nfunction SourceInfo(body) {\n  var result = 'break in ';\n\n  if (body.script) {\n    if (body.script.name) {\n      var name = body.script.name,\n          dir = path.resolve() + '/';\n\n      // Change path to relative, if possible\n      if (name.indexOf(dir) === 0) {\n        name = name.slice(dir.length);\n      }\n\n      result += name;\n    } else {\n      result += '[unnamed]';\n    }\n  }\n  result += ':';\n  result += body.sourceLine + 1;\n\n  return result;\n}\n\n// This class is the repl-enabled debugger interface which is invoked on\n// \"node debug\"\nfunction Interface(stdin, stdout, args) {\n  var self = this,\n      child;\n\n  this.stdin = stdin;\n  this.stdout = stdout;\n  this.args = args;\n\n  var streams = {\n    stdin: stdin,\n    stdout: stdout\n  };\n\n  // Two eval modes are available: controlEval and debugEval\n  // But controlEval is used by default\n  this.repl = new repl.REPLServer('debug> ', streams,\n                                  this.controlEval.bind(this), false, true);\n\n  // Kill child process when repl closed or main process is dead\n  this.repl.rli.addListener('close', function() {\n    self.killed = true;\n    self.killChild();\n  });\n\n  process.on('exit', function() {\n    self.killChild();\n  });\n\n\n  var proto = Interface.prototype,\n      ignored = ['pause', 'resume', 'exitRepl', 'handleBreak',\n                 'requireConnection', 'killChild', 'trySpawn',\n                 'controlEval', 'debugEval', 'print', 'childPrint',\n                 'clearline'],\n      shortcut = {\n        'run': 'r',\n        'cont': 'c',\n        'next': 'n',\n        'step': 's',\n        'out': 'o',\n        'backtrace': 'bt',\n        'setBreakpoint': 'sb',\n        'clearBreakpoint': 'cb'\n      };\n\n  function defineProperty(key, protoKey) {\n    // Check arity\n    var fn = proto[protoKey].bind(self);\n\n    if (proto[protoKey].length === 0) {\n      Object.defineProperty(self.repl.context, key, {\n        get: fn,\n        enumerable: true,\n        configurable: false\n      });\n    } else {\n      self.repl.context[key] = fn;\n    }\n  };\n\n  // Copy all prototype methods in repl context\n  // Setup them as getters if possible\n  for (var i in proto) {\n    if (Object.prototype.hasOwnProperty.call(proto, i) &&\n        ignored.indexOf(i) === -1) {\n      defineProperty(i, i);\n      if (shortcut[i]) defineProperty(shortcut[i], i);\n    }\n  }\n\n  this.killed = false;\n  this.waiting = null;\n  this.paused = 0;\n  this.context = this.repl.context;\n  this.history = {\n    debug: [],\n    control: []\n  };\n  this.breakpoints = [];\n  this._watchers = [];\n\n  // Run script automatically\n  this.pause();\n\n  // XXX Need to figure out why we need this delay\n  setTimeout(function() {\n\n    self.run(function() {\n      self.resume();\n    });\n  }, 10);\n}\n\n\n// Stream control\n\n\nInterface.prototype.pause = function() {\n  if (this.killed || this.paused++ > 0) return false;\n  this.repl.rli.pause();\n  this.stdin.pause();\n};\n\nInterface.prototype.resume = function(silent) {\n  if (this.killed || this.paused === 0 || --this.paused !== 0) return false;\n  this.repl.rli.resume();\n  if (silent !== true) {\n    this.repl.displayPrompt();\n  }\n  this.stdin.resume();\n\n  if (this.waiting) {\n    this.waiting();\n    this.waiting = null;\n  }\n};\n\n\n// Clear current line\nInterface.prototype.clearline = function() {\n  if (this.stdout.isTTY) {\n    this.stdout.cursorTo(0);\n    this.stdout.clearLine(1);\n  } else {\n    this.stdout.write('\\b');\n  }\n};\n\n// Print text to output stream\nInterface.prototype.print = function(text, oneline) {\n  if (this.killed) return;\n  this.clearline();\n\n  this.stdout.write(typeof text === 'string' ? text : util.inspect(text));\n\n  if (oneline !== true) {\n    this.stdout.write('\\n');\n  }\n};\n\n// Format and print text from child process\nInterface.prototype.childPrint = function(text) {\n  this.print(text.toString().split(/\\r\\n|\\r|\\n/g).filter(function(chunk) {\n    return chunk;\n  }).map(function(chunk) {\n    return '< ' + chunk;\n  }).join('\\n'));\n  this.repl.displayPrompt();\n};\n\n// Errors formatting\nInterface.prototype.error = function(text) {\n  this.print(text);\n  this.resume();\n};\n\n\n// Debugger's `break` event handler\nInterface.prototype.handleBreak = function(r) {\n  var self = this;\n\n  this.pause();\n\n  // Save execution context's data\n  this.client.currentSourceLine = r.sourceLine;\n  this.client.currentSourceLineText = r.sourceLineText;\n  this.client.currentSourceColumn = r.sourceColumn;\n  this.client.currentFrame = 0;\n  this.client.currentScript = r.script && r.script.name;\n\n  // Print break data\n  this.print(SourceInfo(r));\n\n  // Show watchers' values\n  this.watchers(true, function(err) {\n    if (err) return self.error(err);\n\n    // And list source\n    self.list(2);\n\n    self.resume(true);\n  });\n};\n\n\n// Internal method for checking connection state\nInterface.prototype.requireConnection = function() {\n  if (!this.client) {\n    this.error('App isn\\'t running... Try `run` instead');\n    return false;\n  }\n  return true;\n};\n\n\n// Evals\n\n// Used for debugger's commands evaluation and execution\nInterface.prototype.controlEval = function(code, context, filename, callback) {\n  try {\n    // Repeat last command if empty line are going to be evaluated\n    if (this.repl.rli.history && this.repl.rli.history.length > 0) {\n      if (code === '(undefined\\n)') {\n        code = '(' + this.repl.rli.history[0] + '\\n)';\n      }\n    }\n\n    var result = vm.runInContext(code, context, filename);\n\n    // Repl should not ask for next command\n    // if current one was asynchronous.\n    if (this.paused === 0) return callback(null, result);\n\n    // Add a callback for asynchronous command\n    // (it will be automatically invoked by .resume() method\n    this.waiting = function() {\n      callback(null, result);\n    };\n  } catch (e) {\n    callback(e);\n  }\n};\n\n// Used for debugger's remote evaluation (`repl`) commands\nInterface.prototype.debugEval = function(code, context, filename, callback) {\n  if (!this.requireConnection()) return;\n\n  var self = this,\n      client = this.client;\n\n  // Repl asked for scope variables\n  if (code === '.scope') {\n    client.reqScopes(callback);\n    return;\n  }\n\n  var frame = client.currentFrame === NO_FRAME ? frame : undefined;\n\n  self.pause();\n\n  // Request remote evaluation globally or in current frame\n  client.reqFrameEval(code, frame, function(err, res) {\n    if (err) {\n      callback(err);\n      self.resume(true);\n      return;\n    }\n\n    // Request object by handles (and it's sub-properties)\n    client.mirrorObject(res, 3, function(err, mirror) {\n      callback(null, mirror);\n      self.resume(true);\n    });\n  });\n};\n\n\n// Utils\n\n// Returns number of digits (+1)\nfunction intChars(n) {\n  // TODO dumb:\n  if (n < 50) {\n    return 3;\n  } else if (n < 950) {\n    return 4;\n  } else if (n < 9950) {\n    return 5;\n  } else {\n    return 6;\n  }\n}\n\n// Adds spaces and prefix to number\nfunction leftPad(n, prefix) {\n  var s = n.toString(),\n      nchars = intChars(n),\n      nspaces = nchars - s.length - 1;\n\n  prefix || (prefix = ' ');\n\n  for (var i = 0; i < nspaces; i++) {\n    prefix += ' ';\n  }\n\n  return prefix + s;\n}\n\n\n// Commands\n\n\n// Print help message\nInterface.prototype.help = function() {\n  this.print(helpMessage);\n};\n\n\n// Run script\nInterface.prototype.run = function() {\n  var callback = arguments[0];\n\n  if (this.child) {\n    this.error('App is already running... Try `restart` instead');\n    callback && callback(true);\n  } else {\n    this.trySpawn(callback);\n  }\n};\n\n\n// Restart script\nInterface.prototype.restart = function() {\n  if (!this.requireConnection()) return;\n\n  var self = this;\n\n  self.pause();\n  self.killChild();\n\n  // XXX need to wait a little bit for the restart to work?\n  setTimeout(function() {\n    self.trySpawn();\n    self.resume();\n  }, 1000);\n};\n\n\n// Print version\nInterface.prototype.version = function() {\n  if (!this.requireConnection()) return;\n\n  var self = this;\n\n  this.pause();\n  this.client.reqVersion(function(err, v) {\n    if (err) {\n      self.error(err);\n    } else {\n      self.print(v);\n    }\n    self.resume();\n  });\n};\n\n// List source code\nInterface.prototype.list = function(delta) {\n  if (!this.requireConnection()) return;\n\n  delta || (delta = 5);\n\n  var self = this,\n      client = this.client,\n      from = client.currentSourceLine - delta + 1,\n      to = client.currentSourceLine + delta + 1;\n\n  self.pause();\n  client.reqSource(from, to, function(err, res) {\n    if (err || !res) {\n      self.error('You can\\'t list source code right now');\n      self.resume();\n      return;\n    }\n\n    var lines = res.source.split('\\n');\n    for (var i = 0; i < lines.length; i++) {\n      var lineno = res.fromLine + i + 1;\n      if (lineno < from || lineno > to) continue;\n\n      var current = lineno == 1 + client.currentSourceLine,\n          breakpoint = client.breakpoints.some(function(bp) {\n            return bp.script === client.currentScript &&\n                   bp.line == lineno;\n          });\n\n      if (lineno == 1) {\n        // The first line needs to have the module wrapper filtered out of\n        // it.\n        var wrapper = require('module').wrapper[0];\n        lines[i] = lines[i].slice(wrapper.length);\n\n        client.currentSourceColumn -= wrapper.length;\n      }\n\n      // Highlight executing statement\n      var line;\n      if (current) {\n        line = SourceUnderline(lines[i],\n                               client.currentSourceColumn,\n                               self.stdout.isTTY);\n      } else {\n        line = lines[i];\n      }\n\n      self.print(leftPad(lineno, breakpoint && '*') + ' ' + line);\n    }\n    self.resume();\n  });\n};\n\n// Print backtrace\nInterface.prototype.backtrace = function() {\n  if (!this.requireConnection()) return;\n\n  var self = this,\n      client = this.client;\n\n  self.pause();\n  client.fullTrace(function(err, bt) {\n    if (err) {\n      self.error('Can\\'t request backtrace now');\n      self.resume();\n      return;\n    }\n\n    if (bt.totalFrames == 0) {\n      self.print('(empty stack)');\n    } else {\n      var trace = [],\n          firstFrameNative = bt.frames[0].script.isNative;\n\n      for (var i = 0; i < bt.frames.length; i++) {\n        var frame = bt.frames[i];\n        if (!firstFrameNative && frame.script.isNative) break;\n\n        var text = '#' + i + ' ';\n        if (frame.func.inferredName && frame.func.inferredName.length > 0) {\n          text += frame.func.inferredName + ' ';\n        }\n        text += path.basename(frame.script.name) + ':';\n        text += (frame.line + 1) + ':' + (frame.column + 1);\n\n        trace.push(text);\n      }\n\n      self.print(trace.join('\\n'));\n    }\n\n    self.resume();\n  });\n};\n\n\n// First argument tells if it should display internal node scripts or not\n// (available only for internal debugger's functions)\nInterface.prototype.scripts = function() {\n  if (!this.requireConnection()) return;\n\n  var client = this.client,\n      displayNatives = arguments[0] || false,\n      scripts = [];\n\n  this.pause();\n  for (var id in client.scripts) {\n    var script = client.scripts[id];\n    if (typeof script == 'object' && script.name) {\n      if (displayNatives ||\n          script.name == client.currentScript ||\n          !script.isNative) {\n        scripts.push(\n            (script.name == client.currentScript ? '* ' : '  ') +\n            id + ': ' +\n            path.basename(script.name)\n        );\n      }\n    }\n  }\n  this.print(scripts.join('\\n'));\n  this.resume();\n};\n\n\n// Continue execution of script\nInterface.prototype.cont = function() {\n  if (!this.requireConnection()) return;\n  this.pause();\n\n  var self = this;\n  this.client.reqContinue(function(err) {\n    if (err) self.error(err);\n    self.resume();\n  });\n};\n\n\n// Step commands generator\nInterface.stepGenerator = function(type, count) {\n  return function() {\n    if (!this.requireConnection()) return;\n\n    var self = this;\n\n    self.pause();\n    self.client.step(type, count, function(err, res) {\n      if (err) self.error(err);\n      self.resume();\n    });\n  };\n};\n\n\n// Jump to next command\nInterface.prototype.next = Interface.stepGenerator('next', 1);\n\n\n// Step in\nInterface.prototype.step = Interface.stepGenerator('in', 1);\n\n\n// Step out\nInterface.prototype.out = Interface.stepGenerator('out', 1);\n\n\n// Watch\nInterface.prototype.watch = function(expr) {\n  this._watchers.push(expr);\n};\n\n// Unwatch\nInterface.prototype.unwatch = function(expr) {\n  var index = this._watchers.indexOf(expr);\n\n  // Unwatch by expression\n  // or\n  // Unwatch by watcher number\n  this._watchers.splice(index !== -1 ? index : +expr, 1);\n};\n\n// List watchers\nInterface.prototype.watchers = function() {\n  var self = this,\n      verbose = arguments[0] || false,\n      callback = arguments[1] || function() {},\n      waiting = this._watchers.length,\n      values = [];\n\n  this.pause();\n\n  if (!waiting) {\n    this.resume();\n\n    return callback();\n  }\n\n  this._watchers.forEach(function(watcher, i) {\n    self.debugEval(watcher, null, null, function(err, value) {\n      values[i] = err ? '<error>' : value;\n      wait();\n    });\n  });\n\n  function wait() {\n    if (--waiting === 0) {\n      if (verbose) self.print('Watchers:');\n\n      self._watchers.forEach(function(watcher, i) {\n        self.print(leftPad(i, ' ') + ': ' + watcher + ' = ' +\n                   JSON.stringify(values[i]));\n      });\n\n      if (verbose) self.print('');\n\n      self.resume();\n\n      callback(null);\n    }\n  }\n};\n\n// Add breakpoint\nInterface.prototype.setBreakpoint = function(script, line,\n                                             condition, silent) {\n  if (!this.requireConnection()) return;\n\n  var self = this,\n      scriptId,\n      ambiguous;\n\n  // setBreakpoint() should insert breakpoint on current line\n  if (script === undefined) {\n    script = this.client.currentScript;\n    line = this.client.currentSourceLine + 1;\n  }\n\n  if (/\\(\\)$/.test(script)) {\n    // setBreakpoint('functionname()');\n    var req = {\n      type: 'function',\n      target: script.replace(/\\(\\)$/, ''),\n      condition: condition\n    };\n  } else {\n    // setBreakpoint('scriptname')\n    if (script != +script && !this.client.scripts[script]) {\n      var scripts = this.client.scripts;\n      Object.keys(scripts).forEach(function(id) {\n        if (scripts[id] && scripts[id].name.indexOf(script) !== -1) {\n          if (scriptId) {\n            ambiguous = true;\n          }\n          scriptId = id;\n        }\n      });\n    } else {\n      scriptId = script;\n    }\n\n    if (!scriptId) return this.error('Script : ' + script + ' not found');\n    if (ambiguous) return this.error('Script name is ambiguous');\n    if (line <= 0) return this.error('Line should be a positive value');\n\n    var req = {\n      type: 'scriptId',\n      target: scriptId,\n      line: line - 1,\n      condition: condition\n    };\n  }\n\n  self.pause();\n  self.client.setBreakpoint(req, function(err, res) {\n    if (err) {\n      if (!silent) {\n        self.error(err);\n      }\n    } else {\n      if (!silent) {\n        self.list(5);\n      }\n\n      // Try load scriptId and line from response\n      if (!scriptId) {\n        scriptId = res.script_id;\n        line = res.line;\n      }\n\n      // If we finally have one - remember this breakpoint\n      if (scriptId) {\n        self.client.breakpoints.push({\n          id: res.breakpoint,\n          scriptId: scriptId,\n          script: (self.client.scripts[scriptId] || {}).name,\n          line: line,\n          condition: condition\n        });\n      }\n\n    }\n    self.resume();\n  });\n};\n\n// Clear breakpoint\nInterface.prototype.clearBreakpoint = function(script, line) {\n  if (!this.requireConnection()) return;\n\n  var ambiguous,\n      breakpoint,\n      index;\n\n  this.client.breakpoints.some(function(bp, i) {\n    if (bp.scriptId === script || bp.script.indexOf(script) !== -1) {\n      if (index !== undefined) {\n        ambiguous = true;\n      }\n      if (bp.line === line) {\n        index = i;\n        breakpoint = bp.id;\n        return true;\n      }\n    }\n  });\n\n  if (ambiguous) return this.error('Script name is ambiguous');\n\n  if (breakpoint === undefined) {\n    return this.error('Script : ' + script + ' not found');\n  }\n\n  var self = this,\n      req = {\n        breakpoint: breakpoint\n      };\n\n  self.pause();\n  self.client.clearBreakpoint(req, function(err, res) {\n    if (err) {\n      self.error(err);\n    } else {\n      self.client.breakpoints.splice(index, 1);\n      self.list(5);\n    }\n    self.resume();\n  });\n};\n\n\n// Show breakpoints\nInterface.prototype.breakpoints = function() {\n  if (!this.requireConnection()) return;\n\n  this.pause();\n  var self = this;\n  this.client.listbreakpoints(function(err, res) {\n    if (err) {\n      self.error(err);\n    } else {\n      self.print(res);\n      self.resume();\n    }\n  });\n};\n\n\n// Kill child process\nInterface.prototype.kill = function() {\n  if (!this.child) return;\n  this.killChild();\n};\n\n\n// Activate debug repl\nInterface.prototype.repl = function() {\n  if (!this.requireConnection()) return;\n\n  var self = this;\n\n  self.print('Press Ctrl + C to leave debug repl');\n\n  // Don't display any default messages\n  var listeners = this.repl.rli.listeners('SIGINT');\n  this.repl.rli.removeAllListeners('SIGINT');\n\n  // Exit debug repl on Ctrl + C\n  this.repl.rli.once('SIGINT', function() {\n    // Restore all listeners\n    process.nextTick(function() {\n      listeners.forEach(function(listener) {\n        self.repl.rli.on('SIGINT', listener);\n      });\n    });\n\n    // Exit debug repl\n    self.exitRepl();\n  });\n\n  // Set new\n  this.repl.eval = this.debugEval.bind(this);\n  this.repl.context = {};\n\n  // Swap history\n  this.history.control = this.repl.rli.history;\n  this.repl.rli.history = this.history.debug;\n\n  this.repl.prompt = '> ';\n  this.repl.rli.setPrompt('> ');\n  this.repl.displayPrompt();\n};\n\n\n// Exit debug repl\nInterface.prototype.exitRepl = function() {\n  // Restore eval\n  this.repl.eval = this.controlEval.bind(this);\n\n  // Swap history\n  this.history.debug = this.repl.rli.history;\n  this.repl.rli.history = this.history.control;\n\n  this.repl.context = this.context;\n  this.repl.prompt = 'debug> ';\n  this.repl.rli.setPrompt('debug> ');\n  this.repl.displayPrompt();\n};\n\n\n// Quit\nInterface.prototype.quit = function() {\n  this.killChild();\n  process.exit(0);\n};\n\n\n// Kills child process\nInterface.prototype.killChild = function() {\n  if (this.child) {\n    this.child.kill();\n    this.child = null;\n  }\n\n  if (this.client) {\n    // Save breakpoints\n    this.breakpoints = this.client.breakpoints;\n\n    this.client.destroy();\n    this.client = null;\n  }\n};\n\n\n// Spawns child process (and restores breakpoints)\nInterface.prototype.trySpawn = function(cb) {\n  var self = this,\n      breakpoints = this.breakpoints || [],\n      port = exports.port,\n      host = 'localhost';\n\n  this.killChild();\n\n  // Connecting to remote debugger\n  // `node debug localhost:5858`\n  if (this.args.length === 2) {\n    var match = this.args[1].match(/^([^:]+):(\\d+)$/);\n    if (match) {\n      host = match[1];\n      port = parseInt(match[2], 10);\n      this.child = {\n        kill: function() {\n          // TODO Do we really need to handle it?\n        }\n      };\n    }\n  } else if (this.args.length === 3) {\n    // `node debug -p pid`\n    if (this.args[1] === '-p' && /^\\d+$/.test(this.args[2])) {\n      this.child = {\n        kill: function() {\n          // TODO Do we really need to handle it?\n        }\n      };\n      process._debugProcess(parseInt(this.args[2], 10));\n    }\n  }\n\n  if (!this.child) {\n    this.child = spawn(process.execPath, this.args);\n\n    this.child.stdout.on('data', this.childPrint.bind(this));\n    this.child.stderr.on('data', this.childPrint.bind(this));\n  }\n\n  this.pause();\n\n  var client = self.client = new Client(),\n      connectionAttempts = 0;\n\n  client.once('ready', function() {\n    self.stdout.write(' ok\\n');\n\n    // Restore breakpoints\n    breakpoints.forEach(function(bp) {\n      self.setBreakpoint(bp.scriptId, bp.line, bp.condition, true);\n    });\n\n    if (cb) cb();\n\n    self.resume();\n\n    client.on('close', function() {\n      self.pause();\n      self.print('program terminated');\n      self.resume();\n      self.client = null;\n      self.killChild();\n    });\n  });\n\n  client.on('unhandledResponse', function(res) {\n    self.pause();\n    self.print('\\nunhandled res:' + JSON.stringify(res));\n    self.resume();\n  });\n\n  client.on('break', function(res) {\n    self.handleBreak(res.body);\n  });\n\n  client.on('error', connectError);\n  function connectError() {\n    // If it's failed to connect 4 times then don't catch the next error\n    if (connectionAttempts >= 10) {\n      client.removeListener('error', connectError);\n    }\n    setTimeout(attemptConnect, 500);\n  }\n\n  function attemptConnect() {\n    ++connectionAttempts;\n    self.stdout.write('.');\n    client.connect(port, host);\n  }\n\n  setTimeout(function() {\n    self.print('connecting..', true);\n    attemptConnect();\n  }, 50);\n};\n})", "gear:_debugger")(exports, require, module);
}
static NativeModule _module__debugger("_debugger", _setup__debugger);