license {
    // Copyright Joyent, Inc. and other Node contributors.
    //           (c) 2011 the gearbox-node project authors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
}

header {
    namespace Gearbox {
        enum encoding {ASCII, UTF8, BASE64, UCS2, BINARY, HEX};
        
        class Buffer : public Value {
            public:
                static bool is(const Value &that) {
                    if(!that.is<Object>())
                        return false;
                    return that.to<v8::Handle<v8::Object>>()->GetIndexedPropertiesExternalArrayDataType() == v8::kExternalUnsignedByteArray;
                }
                
                static uint8_t *data(const Value &that) {
                    return static_cast<uint8_t*>(that.to<v8::Handle<v8::Object>>()->GetIndexedPropertiesExternalArrayData());
                }
                
                static size_t length(const Value &that) {
                    return that.to<v8::Handle<v8::Object>>()->GetIndexedPropertiesExternalArrayDataLength();
                }
        };
    }
}

top {
    #include <assert.h>
    
    typedef void (*freeCallback)(uint8_t *data, void *hint);
    
    enum encoding parseEncoding(String encodingString, enum encoding _default) {
        if(!encodingString.length())
            return _default;
        
        if(encodingString.caseCompare("utf8") || encodingString.caseCompare("utf-8"))
            return UTF8;
        else if(encodingString.caseCompare("ascii"))
            return ASCII;
        else if(encodingString.caseCompare("base64"))
            return BASE64;
        else if(encodingString.caseCompare("ucs2") || encodingString.caseCompare("ucs-2"))
            return UCS2;
        else if(encodingString.caseCompare("binary"))
            return BINARY;
        else if(encodingString.caseCompare("hex"))
            return HEX;
        else if(encodingString.caseCompare("raw")) {
            std::cerr << "'raw' (array of integers) has been removed. Use 'binary'.\n";
            return BINARY;
        } else if(encodingString.caseCompare("raws")) {
            std::cerr << "'raws' encoding has been renamed to 'binary'. Please update your code.\n";
            return BINARY;
        }
        return _default;
    }
    
    Value encodeString(const void *buffer, size_t length, enum encoding encoding) {
        if(!length)
            return "";
    
        if(encoding == BINARY) {
            const uint8_t *cbuffer = static_cast<const uint8_t*>(buffer);
            uint16_t *buffer16 = new uint16_t[length];
            for(size_t i = 0; i < length; i++)
                // XXX is the following line platform independent?
                buffer16[i] = cbuffer[i];
            var chunk = v8::String::New(buffer16, length);
            delete [] buffer16; // TODO use ExternalTwoByteString?
            return chunk;
        }
    
        // utf-8 or ascii encoding
        return String(static_cast<const char*>(buffer), length);
    }

    /*struct SlowBuffer {
            typedef void (*freeCallback)(uint8_t *data, void *hint);
            
            //SlowBuffer();
            
            static void replace(Value &_this, uint8_t *data, size_t length, freeCallback callback, void *hint) {
                BUFFER(_this);
                if(buffer->m_pCallback)
                    buffer->m_pCallback(buffer->m_pData, buffer->m_pCallbackHint);
                else if(buffer->m_nLength) {
                    delete [] buffer->m_pData;
                    v8::V8::AdjustAmountOfExternalAllocatedMemory(-(sizeof(SlowBuffer) + buffer->m_nLength));
                }
                
                buffer->m_nLength = length;
                buffer->m_pCallback = callback;
                buffer->m_pCallbackHint = hint;
                
                if(buffer->m_pCallback) // If it's got a callback, use provided data.
                    buffer->m_pData = data;
                else if(length) {
                    buffer->m_pData = new uint8_t [buffer->m_nLength];
                    if(data)
                        memcpy(buffer->m_pData, data, buffer->m_nLength);
                    v8::V8::AdjustAmountOfExternalAllocatedMemory(sizeof(SlowBuffer) + buffer->m_nLength);
                } else
                    buffer->m_pData = 0;
                
                _this.to<v8::Handle<v8::Object>>()->SetIndexedPropertiesToExternalArrayData(buffer->m_pData, v8::kExternalUnsignedByteArray, buffer->m_nLength);
                _this["length"] = buffer->m_nLength;
            }

            size_t m_nLength;
            uint8_t *m_pData;
            freeCallback m_pCallback;
            void *m_pCallbackHint;
    };*/
    
    // Returns number of bytes written.
    ssize_t decodeWrite(uint8_t *_buffer, size_t length, Value val, enum encoding encoding) {
        // XXX
        // A lot of improvement can be made here. See:
        // http://code.google.com/p/v8/issues/detail?id=270
        // http://groups.google.com/group/v8-dev/browse_thread/thread/dba28a81d9215291/ece2b50a3b4022c
        // http://groups.google.com/group/v8-users/browse_thread/thread/1f83b0ba1f0a611
        
        if(val.is<Array>()) {
            std::cerr << "'raw' encoding (array of integers) has been removed. Use 'binary'.\n";
            assert(0);
            return -1;
        }
        
        char *buffer = reinterpret_cast<char*>(_buffer);
        
        v8::Handle<v8::String> str = val;
        
        if(encoding == UTF8) {
            str->WriteUtf8(buffer, length, NULL, v8::String::HINT_MANY_WRITES_EXPECTED);
            return length;
        }
        
        if(encoding == UCS2) {
            str->Write(reinterpret_cast<uint16_t*>(buffer), 0, length, v8::String::HINT_MANY_WRITES_EXPECTED);
            return length;
        }
        
        if(encoding == ASCII) {
            str->WriteAscii(buffer, 0, length, v8::String::HINT_MANY_WRITES_EXPECTED);
            return length;
        }
        
        // THIS IS AWFUL!!! FIXME
        
        assert(encoding == BINARY);
        
        uint16_t *buffer16 = new uint16_t [length];
        
        str->Write(buffer16, 0, length, v8::String::HINT_MANY_WRITES_EXPECTED);
        
        for(size_t i = 0; i < length; i++)
            buffer[i] = buffer16[i];
        
        delete [] buffer16;
        
        return length;
    }
    
    static size_t base64DecodedSize(const String &str) {
        size_t size = str.length();
        const char *const end = *str + size;
        const size_t remainder = size % 4;
        
        size = (size / 4) * 3;
        if(remainder) {
            // Special case: 1-byte input cannot be decoded
            if(size == 0 && remainder == 1)
                size = 0;
            // Non-padded input, add 1 or 2 extra bytes
            else
                size += 1 + (remainder == 3);
        }
        
        // Check for trailing padding (1 or 2 bytes)
        if(size > 0) {
            if(end[-1] == '=')
                size--;
            if(str[-2] == '=')
                size--;
        }
        
        return size;
    }
    
    static const char *base64_table = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                                      "abcdefghijklmnopqrstuvwxyz"
                                      "0123456789+/";
    static const int8_t unbase64_table[] = {
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-2,-1,-1,-2,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,
        52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,
        -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,
        15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,
        -1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,
        41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
    };
#define unbase64(x) unbase64_table[uint8_t(x)]

#define SLICE_ARGS                                    \
    ssize_t start = _start;                           \
    ssize_t end = _end;                               \
    if(start < 0 || end < 0)                          \
        THROW_TYPE_ERROR("Bad argument.");            \
    if(start > end)                                   \
        THROW_ERROR("Must have start <= end");        \
    if(size_t(end) > This.nLength)                    \
        THROW_ERROR("end cannot be longer than length");
}

module buffer {
    object binding {
        class SlowBuffer {
            native size_t nLength = 0;
            native uint8_t *pData = NULL;
            native freeCallback pCallback = NULL;
            native void *pCallbackHint = NULL;
            
            var length = 0;
            
            SlowBuffer(length) {
                this.nLength = length;
                if(this.nLength) {
                    this.pData = new uint8_t [this.nLength];
                    v8::V8::AdjustAmountOfExternalAllocatedMemory(length);
                } else
                    this.pData = 0;
                
                this.to<v8::Handle<v8::Object>>()->SetIndexedPropertiesToExternalArrayData(this.pData, v8::kExternalUnsignedByteArray, this.nLength);
                this["length"] = this.nLength;
            }
            
            binarySlice(_start, _end) {SLICE_ARGS
                return encodeString(this.pData + start, end - start, BINARY);
            }	
            asciiSlice(_start, _end) {SLICE_ARGS
                return String(this.pData + start, end - start);
            }
            utf8Slice(_start, _end) {SLICE_ARGS
                return String(this.pData + start, end - start);
            }
            ucs2Slice(_start, _end) {SLICE_ARGS
                return v8::String::New(reinterpret_cast<uint16_t*>(this.pData + start), (end - start) / 2);
            }
            base64Slice(_start, _end) {SLICE_ARGS
                int n = end - start;
                int out_len = (n + 2 - ((n + 2) % 3)) / 3 * 4;
                char *out = new char[out_len];
                
                uint8_t bitbuf[3];
                int i = start; // data() index
                int j = 0; // out index
                char c;
                bool b1_oob, b2_oob;
                
                while (i < end) {
                    bitbuf[0] = this.pData[i++];
                    
                    if (i < end) {
                        bitbuf[1] = this.pData[i];
                        b1_oob = false;
                    }  else {
                        bitbuf[1] = 0;
                        b1_oob = true;
                    }
                    i++;
                    
                    if (i < end) {
                        bitbuf[2] = this.pData[i];
                        b2_oob = false;
                    }  else {
                        bitbuf[2] = 0;
                        b2_oob = true;
                    }
                    i++;
                    
                    c = bitbuf[0] >> 2;
                    assert(c < 64);
                    out[j++] = base64_table[int(c)];
                    assert(j < out_len);
                    
                    c = ((bitbuf[0] & 0x03) << 4) | (bitbuf[1] >> 4);
                    assert(c < 64);
                    out[j++] = base64_table[int(c)];
                    assert(j < out_len);
                    
                    if (b1_oob)
                        out[j++] = '=';
                    else {
                        c = ((bitbuf[1] & 0x0F) << 2) | (bitbuf[2] >> 6);
                        assert(c < 64);
                        out[j++] = base64_table[int(c)];
                    }
                    assert(j < out_len);
                    
                    if (b2_oob)
                        out[j++] = '=';
                    else {
                        c = bitbuf[2] & 0x3F;
                        assert(c < 64);
                        out[j++]  = base64_table[int(c)];
                    }
                    assert(j <= out_len);
                }
                
                String string(out, out_len);
                delete [] out;
                return string;
            }

            fill(value, _start, _end) {SLICE_ARGS
                memset(this.pData + start, value.to<uint8_t>(), end - start);
            }
            
            copy(target, _targetStart, _sourceStart) {
                if(!target.is<Buffer>())
                    THROW_TYPE_ERROR("Target should be a Buffer");
                
                uint8_t *targetData = Buffer::data(target);
                ssize_t targetLength = Buffer::length(target);
                ssize_t targetStart = _targetStart, sourceStart = _sourceStart;
                ssize_t sourceEnd = args[3]->IsInt32() ? args[3]->Int32Value() : this.nLength; //FIXME optArgs
                
                if(sourceEnd < sourceStart)
                    THROW_ERROR("sourceEnd < sourceStart");
                
                // Copy 0 bytes; we're done
                if(sourceEnd == sourceStart)
                    return Integer(0);
                
                if(targetStart < 0 || targetStart >= targetLength)
                    THROW_ERROR("targetStart out of bounds");
                
                if(sourceStart < 0 || sourceStart >= this.nLength)
                    THROW_ERROR("sourceStart out of bounds");
                
                if(sourceEnd < 0 || sourceEnd > this.nLength)
                    THROW_ERROR("sourceEnd out of bounds");
                
                ssize_t toCopy = MIN(sourceEnd - sourceStart,
                                 MIN(targetLength - targetStart, this.nLength - sourceStart));
                
                // Need to use slightly slower memmove if the ranges might overlap
                memmove(targetData + targetStart, this.pData + sourceStart, toCopy);
                
                return Integer(toCopy);
            }
            
            binaryWrite(string, _offset) {
                size_t length = string.length(), offset = _offset;
                
                if(length > 0 && offset >= this.nLength)
                    THROW_TYPE_ERROR("Offset is out of bounds");
                
                size_t maxLength = args[2]->IsUndefined() ? this.nLength - offset : args[2]->Uint32Value(); //FIXME optArgs
                maxLength = MIN(length, MIN(this.nLength - offset, maxLength));
                return Integer(decodeWrite(this.pData + offset, maxLength, string, BINARY));
            }
            asciiWrite(string, _offset) {
                v8::Handle<v8::String> s = string;
                size_t length = string.length(), offset = _offset;
                
                if(length > 0 && offset >= this.nLength)
                    THROW_TYPE_ERROR("Offset is out of bounds");
                
                size_t maxLength = args[2]->IsUndefined() ? this.nLength - offset : args[2]->Uint32Value(); //FIXME optArgs
                maxLength = MIN(length, MIN(this.nLength - offset, maxLength));
                return Integer(s->WriteAscii(reinterpret_cast<char*>(this.pData + offset), 0, maxLength,
                                            (v8::String::HINT_MANY_WRITES_EXPECTED | v8::String::NO_NULL_TERMINATION)));
            }
            utf8Write(string, _offset) {
                v8::Handle<v8::String> s = string;
                
                size_t length = string.length();
                if(length == 0)
                    return Integer(0);
                
                size_t offset = _offset;
                
                if(length > 0 && offset >= this.nLength)
                    THROW_TYPE_ERROR("Offset is out of bounds");
                
                size_t maxLength = args[2]->IsUndefined() ? this.nLength - offset : args[2]->Uint32Value(); //FIXME optArgs
                maxLength = MIN(this.nLength - offset, maxLength);
                return Integer(s->WriteUtf8(reinterpret_cast<char*>(this.pData + offset), maxLength, NULL,
                                            (v8::String::HINT_MANY_WRITES_EXPECTED | v8::String::NO_NULL_TERMINATION)));
            }
            ucs2Write(string, _offset) {
                v8::Handle<v8::String> s = string;
                size_t length = string.length(), offset = _offset;
                
                if(length > 0 && offset >= this.nLength)
                    THROW_TYPE_ERROR("Offset is out of bounds");
                
                size_t maxLength = args[2]->IsUndefined() ? this.nLength - offset : args[2]->Uint32Value(); //FIXME optArgs
                maxLength = MIN(this.nLength - offset, maxLength) / 2;
                
                char *p = reinterpret_cast<char*>(this.pData + offset);
                
                int charsWritten;
                return Integer(s->Write(reinterpret_cast<uint16_t*>(this.pData + offset), 0, maxLength,
                                            (v8::String::HINT_MANY_WRITES_EXPECTED | v8::String::NO_NULL_TERMINATION)));
            }
            base64Write(_string, _offset) {
                assert(unbase64('/') == 63);
                assert(unbase64('+') == 62);
                assert(unbase64('T') == 19);
                assert(unbase64('Z') == 25);
                assert(unbase64('t') == 45);
                assert(unbase64('z') == 51);
                
                assert(unbase64(' ') == -2);
                assert(unbase64('\n') == -2);
                assert(unbase64('\r') == -2);
                
                size_t offset = _offset;
                // Handle zero-length buffers graciously
                if(offset == 0 && this.nLength == 0)
                    return Integer(0);
                
                if(offset >= this.nLength)
                    THROW_TYPE_ERROR("Offset is out of bounds");
                
                String string = _string;
                if(base64DecodedSize(string) > this.nLength - offset)
                    THROW_TYPE_ERROR("Buffer too small");
                
                char a, b, c, d;
                char *start = reinterpret_cast<char*>(this.pData + offset);
                char *dst = start;
                const char *src = *string;
                const char *const srcEnd = src + string.length();
                
                while(src < srcEnd) {
                    size_t remaining = srcEnd - src;
                    
                    while(unbase64(*src) < 0 && src < srcEnd)
                        src++, remaining--;
                    if(remaining == 0 || *src == '=')
                        break;
                    a = unbase64(*src++);
                    
                    while(unbase64(*src) < 0 && src < srcEnd)
                        src++, remaining--;
                    if(remaining <= 1 || *src == '=')
                        break;
                    b = unbase64(*src++);
                    *dst++ = (a << 2) | ((b & 0x30) >> 4);
                    
                    while(unbase64(*src) < 0 && src < srcEnd)
                        src++, remaining--;
                    if(remaining <= 2 || *src == '=')
                        break;
                    c = unbase64(*src++);
                    *dst++ = ((b & 0x0F) << 4) | ((c & 0x3C) >> 2);
                    
                    while(unbase64(*src) < 0 && src < srcEnd)
                        src++, remaining--;
                    if(remaining <= 3 || *src == '=')
                        break;
                    d = unbase64(*src++);
                    *dst++ = ((c & 0x03) << 6) | (d & 0x3F);
                }
                
                return Integer(dst - start);
            }
        
            static byteLength(string, _enc) {
                enum encoding enc = parseEncoding(_enc, UTF8);
                
                if(enc == UTF8)
                    return Integer(string.to<v8::Handle<v8::String>>()->Utf8Length());
                if(enc == BASE64)
                    return Integer(base64DecodedSize(string));
                if(enc == UCS2)
                    return Integer(string.length() * 2);
                if(enc == HEX)
                    return Integer(string.length() / 2);
                return Integer(string.length());
            }
            
            static makeFastBuffer(_buffer, fastBuffer, offset, length) {
                if(!_buffer.is<Buffer>())
                    THROW_TYPE_ERROR("First argument must be a Buffer");
                
                v8::Handle<v8::Object> buffer = _buffer;
                fastBuffer.to<v8::Handle<v8::Object>>()->SetIndexedPropertiesToExternalArrayData(
                    static_cast<uint8_t*>(buffer->GetIndexedPropertiesExternalArrayData()) + offset.to<size_t>(),
                    v8::kExternalUnsignedByteArray,length);
            }
        }
    }
    
    js {
//BEGIN lib/buffer.js
//BEGIN #gearbox
//var SlowBuffer = process.binding('buffer').SlowBuffer;
var SlowBuffer = binding.SlowBuffer;
//END #gearbox
var assert = require('assert');

exports.INSPECT_MAX_BYTES = 50;


function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}


SlowBuffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<SlowBuffer ' + out.join(' ') + '>';
};


SlowBuffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};



SlowBuffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


SlowBuffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  SlowBuffer._charsWritten = i * 2;
  return i;
};


SlowBuffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
SlowBuffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};


function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}


// Buffer

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.parent = subject;
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    if (this.length > Buffer.poolSize) {
      // Big buffer, just alloc one.
      this.parent = new SlowBuffer(this.length);
      this.offset = 0;

    } else {
      // Small buffer.
      if (!pool || pool.length - pool.used < this.length) allocPool();
      this.parent = pool;
      this.offset = pool.used;
      pool.used += this.length;
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        this.parent[i + this.offset] = subject[i];
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    }
  }

  SlowBuffer.makeFastBuffer(this.parent, this, this.offset, this.length);
}

function isArrayIsh(subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

exports.SlowBuffer = SlowBuffer;
exports.Buffer = Buffer;

Buffer.poolSize = 8 * 1024;
var pool;

function allocPool() {
  pool = new SlowBuffer(Buffer.poolSize);
  pool.used = 0;
}


// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof SlowBuffer;
};


// Inspect
Buffer.prototype.inspect = function inspect() {
  var out = [],
      len = this.length;

  for (var i = 0; i < len; i++) {
    out[i] = toHex(this.parent[i + this.offset]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }

  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i];
};


Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i] = v;
};


// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  var ret;
  switch (encoding) {
    case 'hex':
      ret = this.parent.hexWrite(string, this.offset + offset, length);
      break;

    case 'utf8':
    case 'utf-8':
      ret = this.parent.utf8Write(string, this.offset + offset, length);
      break;

    case 'ascii':
      ret = this.parent.asciiWrite(string, this.offset + offset, length);
      break;

    case 'binary':
      ret = this.parent.binaryWrite(string, this.offset + offset, length);
      break;

    case 'base64':
      // Warning: maxLength not taken into account in base64Write
      ret = this.parent.base64Write(string, this.offset + offset, length);
      break;

    case 'ucs2':
    case 'ucs-2':
      ret = this.parent.ucs2Write(string, this.offset + offset, length);
      break;

    default:
      throw new Error('Unknown encoding');
  }

  Buffer._charsWritten = SlowBuffer._charsWritten;

  return ret;
};


// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();

  if (typeof start == 'undefined' || start < 0) {
    start = 0;
  } else if (start > this.length) {
    start = this.length;
  }

  if (typeof end == 'undefined' || end > this.length) {
    end = this.length;
  } else if (end < 0) {
    end = 0;
  }

  start = start + this.offset;
  end = end + this.offset;

  switch (encoding) {
    case 'hex':
      return this.parent.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.parent.utf8Slice(start, end);

    case 'ascii':
      return this.parent.asciiSlice(start, end);

    case 'binary':
      return this.parent.binarySlice(start, end);

    case 'base64':
      return this.parent.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.parent.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


// byteLength
Buffer.byteLength = SlowBuffer.byteLength;


// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  return this.parent.fill(value,
                          start + this.offset,
                          end + this.offset);
};


// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  end || (end = this.length);
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  return this.parent.copy(target.parent,
                          target_start + target.offset,
                          start + this.offset,
                          end + this.offset);
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;
  if (end > this.length) throw new Error('oob');
  if (start > end) throw new Error('oob');

  return new Buffer(this.parent, end - start, +start + this.offset);
};


// Legacy methods for backwards compatibility.

Buffer.prototype.utf8Slice = function(start, end) {
  return this.toString('utf8', start, end);
};

Buffer.prototype.binarySlice = function(start, end) {
  return this.toString('binary', start, end);
};

Buffer.prototype.asciiSlice = function(start, end) {
  return this.toString('ascii', start, end);
};

Buffer.prototype.utf8Write = function(string, offset) {
  return this.write(string, offset, 'utf8');
};

Buffer.prototype.binaryWrite = function(string, offset) {
  return this.write(string, offset, 'binary');
};

Buffer.prototype.asciiWrite = function(string, offset) {
  return this.write(string, offset, 'ascii');
};

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  return buffer[offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (isBigEndian) {
    val = buffer[offset] << 8;
    val |= buffer[offset + 1];
  } else {
    val = buffer[offset];
    val |= buffer[offset + 1] << 8;
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (isBigEndian) {
    val = buffer[offset + 1] << 16;
    val |= buffer[offset + 2] << 8;
    val |= buffer[offset + 3];
    val = val + (buffer[offset] << 24 >>> 0);
  } else {
    val = buffer[offset + 2] << 16;
    val |= buffer[offset + 1] << 8;
    val |= buffer[offset];
    val = val + (buffer[offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  neg = buffer[offset] & 0x80;
  if (!neg) {
    return (buffer[offset]);
  }

  return ((0xff - buffer[offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  buffer[offset] = value;
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  if (isBigEndian) {
    buffer[offset] = (value & 0xff00) >>> 8;
    buffer[offset + 1] = value & 0x00ff;
  } else {
    buffer[offset + 1] = (value & 0xff00) >>> 8;
    buffer[offset] = value & 0x00ff;
  }
}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  if (isBigEndian) {
    buffer[offset] = (value >>> 24) & 0xff;
    buffer[offset + 1] = (value >>> 16) & 0xff;
    buffer[offset + 2] = (value >>> 8) & 0xff;
    buffer[offset + 3] = value & 0xff;
  } else {
    buffer[offset + 3] = (value >>> 24) & 0xff;
    buffer[offset + 2] = (value >>> 16) & 0xff;
    buffer[offset + 1] = (value >>> 8) & 0xff;
    buffer[offset] = value & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0xf0);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0xf000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0xf0000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};
//END lib/buffer.js
    }
}
