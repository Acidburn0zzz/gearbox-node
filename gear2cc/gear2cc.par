[*

/* Gathering utilities */

function createClass(name, childs) {
    var out = {type:'class', name:name, classes:{}, vars:{}, staticVars:{}, functions:{}};
    for(c in childs) {
        var node = childs[c];
        switch(node.type) {
            case 'class':
                out.classes[node.name] = {classes:node.classes, vars:node.vars, staticVars:node.staticVars, functions:node.functions};
                break;
            case 'function':
                if(!out.functions[node.name])
                    out.functions[node.name] = [{args:node.args, code:node.code, line:node.line}];
                else
                    out.functions[node.name].push({args:node.args, code:node.code, line:node.line});
                break;
            case 'var':
                out.vars[node.name] = {val:node.val};
                break;
            case 'static-var':
                out.staticVars[node.name] = {val:node.val};
                break;
            case 'native-block':
                throw Error("TODO: Native blocks in classes");
        }
    }
    
    return out;
}

function createNamespace(name, childs, line) {
    var out = {type:'namespace', name:name, namespaces:{}, classes:{}, vars:{}, functions:{}, header:""};
    for(c in childs) {
        var node = childs[c];
        switch(node.type) {
            case 'namespace':
                out.namespaces[node.name] = {namespaces:node.namespaces, classes:node.classes, vars:node.vars, functions:node.functions, header:node.header};
                break;
            case 'class':
                out.classes[node.name] = {classes:node.classes, vars:node.vars, staticVars:node.staticVars, functions:node.functions};
                break;
            case 'function':
                if(!out.functions.hasOwnProperty(node.name))
                    out.functions[node.name] = [{args:node.args, code:node.code, line:node.line}];
                else
                    out.functions[node.name].push({args:node.args, code:node.code, line:node.line});
                break;
            case 'var':
                out.vars[node.name] = {val:node.val};
                break;
            case 'native-block':
                if(node.which == 'header')
                    out.header += node.code + "\n";
                else
                    throw Error("TODO: Native block `" + node.which + "`");
        }
    }
    
    if(!out.functions.hasOwnProperty("toString"))
        out.functions["toString"] = [{args:[], code:"return String(\"[object "+name+"]\");", line:line}];
    
    return out;
}

function nLines(s){return s.replace(/[^\n]/g,"").length;}
function nCols(s){return s.replace(/^(.*\n)+/,"").length;}

function makeTabs(n, ch) {
    var s = "";
    for(var i = 0; i < n; i++)
        s += ch;
    return s;
}

function makeLine(tbs, line) {
    return "\n" + tbs + "#line " + line + " \"" + gear.gear + "\"";
}

var lineNumber = 1;
function generateFunctionCode(functions, name, parentObjName, code, class, ctor) {
    var objName = parentObjName + "_" + name, replaces = [], funcCode = "", hasNoArgsVer = false;
    functions.sort(function(a, b) {return b.args.length - a.args.length;});
    for(f in functions) {
        var func = functions[f], replaces = [], tbs = (func.args.length ? "\t\t" : "\t");
        var actualCode = "\n" + tbs + func.code.trim() + "\n";
        
        var argsLine = "";
        for(var _arg in func.args)
            argsLine += (argsLine ? ", " : "") + func.args[_arg].name + "(args[" + _arg + "])";
        if(argsLine)
            actualCode = makeLine(tbs, func.line) + "\n" + tbs + "Value " + argsLine + ";" + actualCode;
        else
            actualCode = makeLine(tbs, func.line + 1) + actualCode;
        
        replaces.push({regex:"\n" + makeTabs(parentObjName.split("_").length, "    "), replace:"\n" + tbs});
        replaces.push({regex:"\\breturn\\b\\s*;", replace:"return undefined;"});
        replaces.push({regex:"\\bthis\\b", replace:"This"});
        
        for(r in replaces) {
            var replace = replaces[r];
            actualCode = actualCode.replace(new RegExp(replace.regex, "g"), replace.replace);
        }
        if(!RegExp("\n"+tbs+"\\breturn\\b[^;]*;\\s*$").exec(actualCode))
            actualCode += tbs + "return undefined;\n";
        
        if(func.args.length)
            funcCode += "\n\tif(args.Length() >= " + func.args.length + ")\n\t{" + actualCode + "\t}\n";
        else {
            funcCode += actualCode;
            hasNoArgsVer = true;
        }
    }
    
    if(class)
        funcCode = "\n\tValue This(args.This());"+funcCode;
    
    if(!hasNoArgsVer)
        funcCode += "\treturn Throw(Error(\"Invalid call to " + parentObjName.replace(/_/g, ".").replace(/^global\./, "") + (ctor ? "" : (class?".prototype":"") + "." + name) + "\"));\n";
    
    code.func += "v8::Handle<v8::Value> __" + objName + "(const v8::Arguments& args) {" + funcCode + "}\n\n";
}

function generateClassCode(class, name, parentObjName, code) {
    var objName = parentObjName + "_" + name;
    
    code.addClass(objName, name);
    
    for(className in class.classes)
        generateClassCode(class.classes[className], className, objName, code);
    
    for(funcName in class.functions) {
        if(funcName != name)
            code.setPrototype(objName, funcName, "Function(__" + objName + "_" + funcName + ", \"" + funcName + "\")");
        generateFunctionCode(class.functions[funcName], funcName, objName, code, class, funcName == name);
    }
    
    for(varName in class.vars) {
        var val = class.vars[varName].val;
        code.setPrototype(objName, varName, /^\s*\b[A-Z]\w+\b\(.+\)$/.test(val) ? val : "Value(" + val + ")");
    }
    
    for(varName in class.staticVars) {
        var val = class.staticVars[varName].val;
        code.setStatic(objName + "->GetFunction()", varName, /^\s*\b[A-Z]\w+\b\(.+\)$/.test(val) ? val : "Value(" + val + ")");
    }
    code.setStatic(parentObjName, name, objName + "->GetFunction()");
}

function generateNamespaceCode(namespace, name, parentObjName, code) {
    var objName = parentObjName + "_" + name;
    
    code.addNamespace(objName);
    code.setStatic(parentObjName, name, objName);
    
    for(className in namespace.classes)
        generateClassCode(namespace.classes[className], className, objName, code);
    
    for(funcName in namespace.functions) {
        code.setStatic(objName, funcName, "Function(__" + objName + "_" + funcName + ", \"" + funcName + "\")");
        generateFunctionCode(namespace.functions[funcName], funcName, objName, code);
    }
    
    for(varName in namespace.vars) {
        var val = namespace.vars[varName].val;
        code.setStatic(objName, varName, /^\s*\b[A-Z]\w+\b\(.+\)$/.test(val) ? val : "Value(" + val + ")");
    }
}

function generateCode(global) {
    var code = {
        func:"", init:"",
        addNamespace: function(objName) {
            this.init += "\tv8::Handle<v8::Object> " + objName + " = v8::Object::New();\n";
        },
        addFunction: function(objName, funcName) {
            objName += "_" + funcName;
            this.init += "\tv8::Handle<v8::Function> " + objName + " = v8::FunctionTemplate::New(__" + objName + ")->GetFunction();\n";
            this.init += "\t" + objName + "->SetName(String(\"" + funcName + "\"));\n";
        },
        addClass: function(objName, ctor) {
            this.init += "\tv8::Handle<v8::FunctionTemplate> " + objName + " = v8::FunctionTemplate::New(__" + objName + "_" + ctor + ");\n";
            this.init += "\t" + objName + "->SetClassName(String(\"" + ctor + "\"));\n";
        },
        setStatic: function(parentObjName, name, value) {
            this.init += "\t" + parentObjName + "->Set(String(\"" + name + "\"), " + value + ");\n";
        },
        setPrototype: function(parentObjName, name, value) {
            this.init += "\t" + parentObjName + "->PrototypeTemplate()->Set(\"" + name + "\", " + value + ");\n";
        },
    };
    
    var namespaces = Object.keys(global.namespaces);
    
    if(!namespaces.length)
        throw Error("No namespace");
    else if(namespaces.length > 1)
        throw Error("Too many namespaces");
    else {
        generateNamespaceCode(global.namespaces[namespaces[0]], namespaces[0], "global", code);
        
        var ccCode = 
'\n\
#include <v8-gearbox.h>\n\
#include "'+baseName+'.h"\n\
\n\
using namespace Gearbox;\n\
\n\
/** \\file '+baseName+'.cc converted from '+baseName+'.gear */\n'+
        makeLine("",1) + "\n" +
        global.header.trim().replace(/\n    /g, "\n") +
        (global.header.trim()?"\n\n":"") + code.func;
        ccCode += makeLine("",nLines(ccCode)+2).replace(".gear",".cc") + "\nvoid Setup" + baseName + "(v8::Handle<v8::Object> global) {\n" + code.init + "}";
        ccCode = ccCode.replace(/\t/g, "    ");
        Io.write(gear.cc, ccCode);
        
        var hCode =
'\n\
#ifndef MODULE_'+baseName.toUpperCase()+'_H\n\
#define MODULE_'+baseName.toUpperCase()+'_H\n\n\
#include <v8.h>\n\n\
void Setup'+baseName+'(v8::Handle<v8::Object> global);\n\n\
#endif\n';
        Io.write(gear.h, hCode);
    }
    
}

*]

    '[ \t\n]+' WHTS
    'namespace'
    'class'
    'function'
    'static'
    'var'
    '\{'
    '\}'
    '\('
    '\)'
    '='
    ';'
    ','
    '\*'
    '/'
    '[A-Za-z_][A-Za-z0-9_]*'        Identifier
    /~'\'([^\']|\\\')*\''             _String                          [* %match = %match.substr(1, %match.length - 2).replace(/\\\'/g, "'" ); *]
    '[0-9]+'                        _Integer
    '[0-9]+\.[0-9]*|[0-9]*\.[0-9]+' _Number~/
    '[^\{\}\(\) \r\n\t=;,\*]+'      Junk
    ;

##

Global: NamespaceContents [* generateCode(createNamespace("global", %1)); *];

Namespace: 'namespace' W Identifier W '{' W NamespaceContents W '}'     [* %% = createNamespace(%3, %7, %2.line); *];

NamespaceContents: NamespaceContents W NamespaceContent W [* %% = %1.concat([%3]); *] | W [* %% = []; *];
                    
NamespaceContent: Namespace | Class | VariableDef | Function | NativeBlock;

Class: 'class' W Identifier W '{' W ClassContents W '}'     [* %% = createClass(%3, %7); *];

ClassContents: ClassContents W ClassContent [* %% = %1.concat([%3]); *] | W [* %% = []; *] ;
                    
ClassContent: Class | VariableDef | Function | NativeBlock;

VariableDef: 'var' W Identifier W '=' W NativeCodeInline W ';' [* %% = {type:'var', name:%3, val:%7}; *]
            |'static' W 'var' W Identifier W '=' W NativeCodeInline W ';' [* %% = {type:'static-var', name:%5, val:%9}; *];
          
Function: 'function' W Identifier W '(' W ArgumentList W ')' W '{' NativeCode '}' [* %% = {type:'function', name:%3, args:%7, code:%12, line:%10.line}; *]
         |'function' W Identifier W '(' W ')' W '{' NativeCode '}'              [* %% = {type:'function', name:%3, args:[], code:%10, line:%8.line}; *]
         ;

ArgumentList: ArgumentList W ',' W Identifier [* %% = (%1).concat([{name:%5}]); *]
             |Identifier                    [* %% = [{name:%1}]; *]
             ;

NativeBlock: Identifier W '{' NativeCode '}'     [* %% = {type:'native-block', which:%1, code:%4}; *];

NativeCodeInline: NativeCode PossibleJunk [* %% = %1 + %2; *]
            | NativeCode '{' NativeCode '}' [* %% = %1 + %2 + %3 + %4; *]
            | NativeCode '(' NativeCode ')' [* %% = %1 + %2 + %3 + %4; *]
            | [* %% = ""; *] ;

NativeCode: NativeCode PossibleJunk         [* %% = %1 + %2; *]
            | NativeCode ';'                [* %% = %1 + %2; *]
            | NativeCode '{' NativeCode '}' [* %% = %1 + %2 + %3 + %4; *]
            | NativeCode '(' NativeCode ')' [* %% = %1 + %2 + %3 + %4; *]
            | [* %% = ""; *] ;

W: W _W [* %% = {s:%1.s + %2.s, line:%2.line}; *] | W '/' '*' MLComment '*' '/' [* %% = {s:%1.s, line:%1.line}; *] | [* %% = {s:"",line:lineNumber}; *];

MLComment: MLComment PossibleJunk
|MLComment ';'
|MLComment '{'
|MLComment '}'
|MLComment '('
|MLComment ')'
|
;

PossibleJunk: Junk
|'namespace'
|'class'
|'function'
|'static'
|'var'
|'='
|','
|'*'
|'/'
|Identifier
|_W [* %% = %1.s; *]
;

_W:WHTS[* lineNumber += %1.replace(/[^\n]/g,"").length; %% = {s:%1,line:lineNumber};*]|[* %%={s:"",line:lineNumber}; *];

[*

//##PREFIX##_dbg_withtrace = true;
//##PREFIX##_dbg_withparsetree = true;
//##PREFIX##_dbg_withstepbystep = true;
var lastSlash = arguments[1].lastIndexOf('/')+1;
var baseDir = arguments[1].substr(0, lastSlash), baseName = arguments[1].substr(lastSlash).replace(/\.gear$/, '');
var gear = {gear:baseDir+baseName+".gear", cc:baseDir+baseName+".cc", h:baseDir+baseName+".h"};
if(arguments.length == 2) {
    var str         = Io.read(gear.gear);
    var error_cnt   = 0;
    var error_off   = [];
    var error_la    = [];
    
    if((error_cnt = __##PREFIX##parse(str, error_off, error_la)) > 0)
        for(var i = 0; i < error_cnt; i++) {
            var bf = str.substr(0, error_off[i]);
            print(gear.gear+":"+(nLines(bf)+1)+":"+(nCols(bf)+1)+": Error near >" + str.substr(error_off[i], 30) + "<, expecting \"" + error_la[i].join() + "\"" );
        }
}
else
    print("usage: " + arguments[0] + " <file>");
exit(); // Just in case v8-gearbox is a (bit) broken
*]
